<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MovingLines - 2D Animation Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .timeline-frame {
            border: 2px solid transparent;
            transition: all 0.2s ease-in-out;
            position: relative; /* For positioning icons */
        }
        .timeline-frame.active {
            border-color: #4f46e5; /* indigo-600 */
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.7);
        }
        .timeline-frame:hover .frame-controls {
            opacity: 1;
        }
        .frame-controls {
            position: absolute;
            top: -8px;
            right: -8px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .frame-control-btn {
            background-color: rgba(40, 50, 70, 0.9);
            border: 1px solid #4b5563; /* gray-600 */
            border-radius: 9999px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .frame-control-btn:hover {
            background-color: #4f46e5;
        }
        .tool-button.active, .layer-button.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border-color: #6366f1; /* indigo-500 */
        }
        .loader {
            border: 4px solid #4b5563; /* gray-600 */
            border-radius: 50%;
            border-top: 4px solid #4f46e5; /* indigo-600 */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            height: 8px;
        }
        .timeline-container::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        .timeline-container::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }

        /* Viewport for Zoom/Pan */
        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            border-radius: 0.5rem;
             background-color: #4b5563; /* gray-600 as fallback */
        }

        .canvas-container {
            position: relative;
            width: 1280px; /* Fixed internal resolution */
            height: 720px;
            transform-origin: 0 0;
        }

        .base-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #onion-skin-canvas-behind,
        #onion-skin-canvas-ahead,
        #preview-canvas { /* preview canvas for shapes */
            pointer-events: none;
        }
        #image-bg-canvas {
             background-color: white;
        }
        /* Disabled button style */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .color-swatch {
            transition: transform 0.1s ease-in-out;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.active {
            box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5;
        }
        .header-btn {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .header-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        [contenteditable]:hover {
            background-color: #334155; /* slate-700 */
        }
        [contenteditable]:focus {
            background-color: #475569; /* slate-600 */
            outline: 2px solid #4f46e5; /* indigo-600 */
        }
    </style>
</head>
<body class="bg-slate-900 text-gray-300 flex flex-col h-screen overflow-hidden">
    <!-- Header -->
    <header class="bg-slate-800 shadow-md p-3 flex justify-between items-center z-20 border-b border-slate-700 flex-shrink-0">
        <h1 id="project-title" contenteditable="true" class="text-lg md:text-xl font-bold text-white whitespace-nowrap px-2 rounded-md outline-none" title="Click to rename">MovingLines</h1>
        <!-- Playback Controls -->
        <div class="hidden md:flex items-center gap-4 absolute left-1/2 -translate-x-1/2">
             <button id="play-pause" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-pause-fill hidden" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>
            </button>
            <div class="flex items-center gap-2">
                <label for="fps-slider" class="text-sm font-medium">FPS:</label>
                <input type="range" id="fps-slider" min="1" max="30" value="12" class="w-24 h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                <span id="fps-value" class="text-sm font-semibold w-6 text-center">12</span>
            </div>
        </div>
        <div class="flex items-center gap-2 md:gap-4">
            <button id="show-instructions" class="header-btn bg-gradient-to-br from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-bold py-2 px-3 md:px-4 rounded-lg text-sm">Help</button>
            <button id="save-project" class="header-btn bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16"><path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v4.5h2a.5.5 0 0 1 .354.854l-2.5 2.5a.5.5 0 0 1-.708 0l-2.5-2.5A.5.5 0 0 1 5.5 6.5h2V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/></svg>
                <span class="hidden md:inline">Save</span>
            </button>
            <label for="load-project-input" class="header-btn bg-gradient-to-br from-yellow-400 to-yellow-500 hover:from-yellow-500 hover:to-yellow-600 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2 cursor-pointer">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder2-open" viewBox="0 0 16 16"><path d="M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.958 0 1.76.746 1.97.684l.248-.06c.26-.06.58.11.732.358L8.5 3.5h5.5A1.5 1.5 0 0 1 15.5 5v.54L14.05 8.4a.5.5 0 0 1-.45.3H5.4a.5.5 0 0 1-.45-.3L3.5 5.54V5.5A1.5 1.5 0 0 1 2 4H1.5V3.5zM2 6h12v5a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6z"/><path d="M.5 4a.5.5 0 0 0 0 1h15a.5.5 0 0 0 0-1H.5z"/></svg>
                <span class="hidden md:inline">Load</span>
            </label>
            <input type="file" id="load-project-input" class="hidden" accept=".anim">
             <button id="open-export-modal-btn" class="header-btn bg-gradient-to-br from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                <span class="hidden md:inline">Export</span>
            </button>
        </div>
    </header>
    <!-- Main Content -->
    <div class="flex flex-col md:flex-row flex-grow overflow-hidden">
        <!-- Toolbar -->
        <aside class="w-full md:w-56 bg-slate-800 p-3 flex-shrink-0 flex flex-col gap-2 overflow-y-auto z-10 border-b md:border-b-0 md:border-r border-slate-700">
            <!-- Layers -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Layer</h3>
                 <div class="flex flex-col gap-2">
                    <button id="animation-layer-btn" class="layer-button active bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Animation</button>
                    <button id="background-layer-btn" class="layer-button bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Background</button>
                </div>
            </div>
            <!-- Tools -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Tool</h3>
                <div id="tools-container" class="grid grid-cols-4 gap-2">
                    <button data-tool="pencil" class="tool-button active p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Pencil">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>
                    </button>
                     <button data-tool="pan" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Pan (Hold Space)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M19,10.5C19,10.22 18.78,10 18.5,10H17V6.5C17,6.22 16.78,6 16.5,6C16.22,6 16,6.22 16,6.5V10H14V4.5C14,4.22 13.78,4 13.5,4C13.22,4 13,4.22 13,4.5V10H11V5.5C11,5.22 10.78,5 10.5,5C10.22,5 10,5.22 10,5.5V10H8.5C7.67,10 7,10.67 7,11.5V17H5.5C5.22,17 5,17.22 5,17.5C5,17.78 5.22,18 5.5,18H7V19.5C7,19.78 7.22,20 7.5,20C7.78,20 8,19.78 8,19.5V18H10.5C11.33,18 12,17.33 12,16.5V11H13.5V18.5C13.5,18.78 13.72,19 14,19C14.28,19 14.5,18.78 14.5,18.5V11H16V19C16,19.28 16.22,19.5 16.5,19.5C16.78,19.5 17,19.28 17,19V11.5C17,10.67 17.67,10 18.5,10H19V10.5Z" />
                        </svg>
                    </button>
                    <button data-tool="eraser" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Eraser">
                         <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm.66 11.34L3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/></svg>
                    </button>
                    <button data-tool="lasso" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Lasso Erase">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5">
                            <path d="M4.23223 15.7678C1.20573 12.7413 1.20573 7.75868 4.23223 4.73223C7.25873 1.70573 12.2413 1.70573 15.2678 4.73223C18.2943 7.75868 18.2943 12.7413 15.2678 15.7678L12.5 18.5L9.5 21.5L4.23223 15.7678Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"/>
                        </svg>
                    </button>
                    <button data-tool="fill" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Paint Bucket">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M16.56,8.94L7.62,0L6.21,1.41L8.59,3.79L3.44,8.94C2.85,9.53 2.85,10.47 3.44,11.06L8.94,16.56C9.23,16.85 9.62,17 10,17C10.38,17 10.77,16.85 11.06,16.56L16.56,11.06C17.15,10.47 17.15,9.53 16.56,8.94M5.21,10L10,5.21L14.79,10M19,12C19,13.1 18.6,14.12 18,15V19C18,20.1 17.1,21 16,21H8C6.9,21 6,20.1 6,19V17H16.76L18.84,14.92C18.93,14 19,13 19,12Z" />
                        </svg>
                    </button>
                     <button data-tool="line" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Line">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.5 19.5L19.5 4.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="rectangle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Rectangle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="circle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Circle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="polygon" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Polygon (Double-click to finish)">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2L2 8L5 20H19L22 8L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <button id="undo-btn" class="p-2 rounded-lg flex justify-center items-center gap-2 bg-slate-700 hover:bg-slate-600 border-2 border-slate-600 text-sm" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
                        </svg>
                        <span>Undo</span>
                    </button>
                    <button id="redo-btn" class="p-2 rounded-lg flex justify-center items-center gap-2 bg-slate-700 hover:bg-slate-600 border-2 border-slate-600 text-sm" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                        <span>Redo</span>
                    </button>
                </div>
            </div>
            <!-- Brush Size -->
            <div>
                <label for="brush-size" class="text-xs font-semibold text-gray-400 uppercase">Brush Size</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="brush-size-value" class="text-sm font-semibold w-6 text-center">5</span>
                </div>
            </div>
            <!-- Color -->
            <div>
                <label for="color-picker" class="text-xs font-semibold mb-1 text-gray-400 uppercase">Color</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="color" id="color-picker" value="#000000" class="w-10 h-10 rounded-lg cursor-pointer border-2 border-slate-600">
                    <div id="color-palette" class="grid grid-cols-5 gap-1 flex-1">
                        <!-- Color swatches will be inserted here -->
                    </div>
                </div>
            </div>
            <!-- Onion Skin -->
            <div class="flex justify-center">
                <label for="onion-skin" class="flex items-center cursor-pointer select-none">
                    <input type="checkbox" id="onion-skin" class="h-5 w-5 rounded border-gray-500 text-indigo-500 focus:ring-indigo-600 bg-slate-700">
                    <span class="ml-3 text-base font-bold">Onion Skin</span>
                </label>
            </div>
            <!-- Background Options -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Background Options</h3>
                <div class="flex flex-col gap-2">
                    <label for="bg-upload-input" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-sm text-center cursor-pointer">Upload Image</label>
                    <input type="file" id="bg-upload-input" class="hidden" accept="image/*">
                    <button id="clear-bg-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg text-sm">Clear Background</button>
                </div>
            </div>
             <!-- Playback for Mobile -->
             <div class="md:hidden">
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Playback</h3>
                <div class="flex items-center justify-center gap-4 mt-2">
                    <button id="play-pause-mobile" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                         <!-- Icons will be cloned here by JS -->
                    </button>
                </div>
                 <div class="flex items-center gap-2 mt-2">
                    <label for="fps-slider-mobile" class="text-sm font-medium">FPS:</label>
                    <input type="range" id="fps-slider-mobile" min="1" max="30" value="12" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="fps-value-mobile" class="text-sm font-semibold w-6 text-center">12</span>
                </div>
            </div>
        </aside>
        <!-- Canvas -->
        <main class="flex-grow flex items-center justify-center p-2 md:p-4 bg-slate-900 overflow-hidden relative">
            <div id="viewport" class="shadow-xl">
                 <div class="canvas-container">
                    <canvas id="image-bg-canvas" class="base-canvas"></canvas>
                    <canvas id="drawing-bg-canvas" class="base-canvas"></canvas>
                    <canvas id="onion-skin-canvas-behind" class="base-canvas"></canvas>
                    <canvas id="animation-canvas" class="base-canvas"></canvas>
                    <canvas id="onion-skin-canvas-ahead" class="base-canvas"></canvas>
                    <canvas id="preview-canvas" class="base-canvas"></canvas>
                </div>
            </div>
            <!-- Zoom Controls -->
            <div class="absolute bottom-4 left-4 bg-slate-800 p-2 rounded-lg shadow-lg flex items-center gap-2 border border-slate-700 z-10">
                <button id="zoom-out-btn" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 rounded-md font-bold text-lg">-</button>
                <span id="zoom-level-display" class="text-sm font-semibold w-12 text-center">100%</span>
                <button id="zoom-in-btn" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 rounded-md font-bold text-lg">+</button>
                <button id="reset-zoom-btn" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 rounded-md" title="Reset Zoom">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-fullscreen-exit" viewBox="0 0 16 16"><path d="M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5zm5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5zM0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zm10 0a.5.5 0 0 1 .5-.5h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 1 0v4A1.5 1.5 0 0 1 14.5 10h-4a.5.5 0 0 1-.5-.5z"/></svg>
                </button>
            </div>
        </main>
    </div>
    <!-- Timeline -->
    <footer class="bg-slate-800 shadow-inner p-3 z-20 border-t border-slate-700 flex-shrink-0">
        <div class="relative flex justify-center items-center mb-2">
            <div class="absolute left-0">
                <h3 class="text-sm font-semibold text-gray-400 uppercase">Timeline</h3>
                <div class="flex items-center gap-4 mt-1">
                    <span id="frame-count" class="text-sm text-gray-400 font-mono">1 / 1</span>
                    <span id="animation-time" class="text-sm text-gray-400 font-mono">0.0s</span>
                </div>
            </div>
            <button id="add-frame" class="bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-4 rounded-lg text-sm flex items-center gap-2" title="Add New Frame">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
                </svg>
                <span>Add Frame</span>
            </button>
        </div>
        <div class="w-full overflow-x-auto overflow-y-hidden pb-2 timeline-container">
            <div id="timeline" class="flex items-start gap-2 p-2 bg-slate-700 rounded-lg min-h-[120px]">
                 <!-- Timeline frames will be inserted here -->
            </div>
        </div>
    </footer>
    
    <!-- Modal for loading spinner -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
        <div class="bg-slate-800 p-8 rounded-lg shadow-xl text-center border border-slate-700">
            <div class="loader mx-auto"></div>
            <p id="loading-text" class="mt-4 text-lg font-medium text-white">Generating...</p>
        </div>
    </div>

    <!-- Export Options Modal -->
    <div id="export-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-slate-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border border-slate-700 relative">
             <button id="close-export-modal-btn" class="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
            <h2 class="text-2xl font-bold mb-6 text-center">Export Animation</h2>
            <div class="flex flex-col gap-4">
                 <button id="export-webm-btn-modal" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg w-full">Export as WebM</button>
                 <button id="export-apng-btn-modal" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg w-full">Export as APNG</button>
            </div>
        </div>
    </div>


    <!-- Instructions Modal -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 text-white p-8 rounded-lg shadow-xl max-w-2xl w-full border border-slate-700 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-6 text-center">How to Use MovingLines</h2>
            <dl class="space-y-4 text-gray-300">
                <div>
                    <dt class="font-bold text-lg text-indigo-400">Layers</dt>
                    <dd>Switch between the 'Animation' layer for moving parts and the 'Background' layer for static scenery.</dd>
                </div>
                <div>
                    <dt class="font-bold text-lg text-indigo-400">Timeline</dt>
                    <dd>Click '+ Add Frame' to add a new drawing canvas. Click on any frame to select it. Hover over a frame to reveal icons to duplicate or delete it.</dd>
                </div>
                <div>
                    <dt class="font-bold text-lg text-indigo-400">Canvas Controls</dt>
                    <dd>
                        <ul class="list-disc list-inside ml-4">
                            <li><b>Zoom:</b> Use the +/- buttons or scroll your mouse wheel.</li>
                            <li><b>Pan:</b> Hold the <code class="bg-slate-700 p-1 rounded">Spacebar</code> and drag your mouse, or select the Pan tool.</li>
                        </ul>
                    </dd>
                </div>
                <div>
                    <dt class="font-bold text-lg text-indigo-400">Tools</dt>
                    <dd>
                        <ul class="list-disc list-inside ml-4">
                            <li><b>Polygon Tool:</b> Click to place points. Double-click to finish the shape.</li>
                            <li><b>Lasso Erase:</b> Draw a selection around the area you want to erase. The tool will clear everything inside the selected shape once you release the mouse.</li>
                        </ul>
                    </dd>
                </div>
                <div>
                    <dt class="font-bold text-lg text-indigo-400">Undo/Redo</dt>
                    <dd>Use the Undo/Redo buttons or press <code class="bg-slate-700 p-1 rounded">Ctrl+Z</code> / <code class="bg-slate-700 p-1 rounded">Ctrl+Y</code>. Each frame and the background layer has its own history.</dd>
                </div>
                 <div>
                    <dt class="font-bold text-lg text-indigo-400">Onion Skin</dt>
                    <dd>Check this box to see faint outlines of the previous and next frames, helping you create smoother motion.</dd>
                </div>
                <div>
                    <dt class="font-bold text-lg text-indigo-400">Save, Load, & Export</dt>
                    <dd>Use the header buttons to save your project as a <code class="bg-slate-700 p-1 rounded">.anim</code> file, load it later, or export your finished animation as a WebM video or an APNG file.</dd>
                </div>
            </dl>
            <div class="mt-8 text-center">
                <button id="close-instructions-modal" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-8 rounded-lg">Got it!</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/apng-js/dist/apng-js.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Canvas & Context Setup ---
            const viewport = document.getElementById('viewport');
            const canvasContainer = document.querySelector('.canvas-container');
            const imageBgCanvas = document.getElementById('image-bg-canvas');
            const drawingBgCanvas = document.getElementById('drawing-bg-canvas');
            const onionBehindCanvas = document.getElementById('onion-skin-canvas-behind');
            const animationCanvas = document.getElementById('animation-canvas');
            const onionAheadCanvas = document.getElementById('onion-skin-canvas-ahead');
            const previewCanvas = document.getElementById('preview-canvas');

            const animCtx = animationCanvas.getContext('2d', { willReadFrequently: true });
            const imageBgCtx = imageBgCanvas.getContext('2d');
            const drawingBgCtx = drawingBgCanvas.getContext('2d', { willReadFrequently: true });
            const onionBehindCtx = onionBehindCanvas.getContext('2d');
            const onionAheadCtx = onionAheadCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            
            // --- DOM Elements ---
            const projectTitleEl = document.getElementById('project-title');
            const animationLayerBtn = document.getElementById('animation-layer-btn');
            const backgroundLayerBtn = document.getElementById('background-layer-btn');
            const toolButtons = document.querySelectorAll('.tool-button');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const colorPicker = document.getElementById('color-picker');
            const colorPalette = document.getElementById('color-palette');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const onionSkinCheckbox = document.getElementById('onion-skin');
            const addFrameBtn = document.getElementById('add-frame');
            const timeline = document.getElementById('timeline');
            const animationTimeEl = document.getElementById('animation-time');
            const frameCountEl = document.getElementById('frame-count');
            
            // Playback
            const playPauseBtn = document.getElementById('play-pause');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const fpsSlider = document.getElementById('fps-slider');
            const fpsValue = document.getElementById('fps-value');
            const playPauseMobileBtn = document.getElementById('play-pause-mobile');
            const fpsSliderMobile = document.getElementById('fps-slider-mobile');
            const fpsValueMobile = document.getElementById('fps-value-mobile');
            
            // Zoom Controls
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const resetZoomBtn = document.getElementById('reset-zoom-btn');
            const zoomLevelDisplay = document.getElementById('zoom-level-display');
            
            // Modals & File I/O
            const openExportModalBtn = document.getElementById('open-export-modal-btn');
            const exportModal = document.getElementById('export-modal');
            const closeExportModalBtn = document.getElementById('close-export-modal-btn');
            const exportWebmBtnModal = document.getElementById('export-webm-btn-modal');
            const exportApngBtnModal = document.getElementById('export-apng-btn-modal');
            const loadingModal = document.getElementById('loading-modal');
            const loadingText = document.getElementById('loading-text');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsModalBtn = document.getElementById('close-instructions-modal');
            const showInstructionsBtn = document.getElementById('show-instructions');
            const saveProjectBtn = document.getElementById('save-project');
            const loadProjectInput = document.getElementById('load-project-input');
            const bgUploadInput = document.getElementById('bg-upload-input');
            const clearBgBtn = document.getElementById('clear-bg-btn');

            // --- State ---
            let frames = [];
            let backgroundData = { current: null, undoStack: [], redoStack: [] };
            let currentFrameIndex = 0;
            let isDrawing = false;
            let lastPos = { x: 0, y: 0 };
            let activeTool = 'pencil';
            let previousTool = 'pencil';
            let activeLayer = 'animation';
            let shapeStartPos = null;
            let polygonPoints = [];
            let isPlaying = false;
            let animationFrameId;
            let lastFrameTime = 0;
            let uploadedBackgroundImage = null;
            let lassoPoints = [];

            let transform = { scale: 1, panX: 0, panY: 0 };
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            const PALETTE_COLORS = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080'];
            
            // --- Helper Functions ---
            
            const getActiveContext = () => activeLayer === 'animation' ? animCtx : drawingBgCtx;
            
            const getActiveHistory = () => {
                if (activeLayer === 'animation') {
                    return frames[currentFrameIndex] || { undoStack: [], redoStack: [] };
                }
                return backgroundData;
            };
            
            const getMousePos = (e) => {
                const rect = animationCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                // Inverse transform the point
                const x = (clientX - rect.left - transform.panX) / transform.scale;
                const y = (clientY - rect.top - transform.panY) / transform.scale;
                
                return { x, y };
            };

            const clearCanvas = (ctx) => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            };

            const saveState = () => {
                const history = getActiveHistory();
                const ctx = getActiveContext();
                history.undoStack.push(ctx.getImageData(0, 0, animationCanvas.width, animationCanvas.height));
                history.redoStack = []; // Clear redo stack on new action
                updateUndoRedoButtons();
            };
            
            // --- Drawing & Tools ---
            
            const startDrawing = (e) => {
                if (activeTool === 'pan' || (e.type === 'mousedown' && e.button !== 0)) return; // Only left click draws
                e.preventDefault();
                isDrawing = true;
                const pos = getMousePos(e);
                lastPos = pos;
                shapeStartPos = pos;
                
                if (activeTool === 'lasso') {
                    lassoPoints = [pos];
                } else if (activeTool === 'polygon') {
                    polygonPoints.push(pos);
                    drawPolygonPreview();
                } else if (activeTool !== 'fill') {
                     saveState();
                }

                if (activeTool === 'pencil' || activeTool === 'eraser') {
                    draw(e);
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                
                const pos = getMousePos(e);
                const ctx = getActiveContext();
                
                ctx.lineWidth = brushSizeSlider.value;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = colorPicker.value;

                switch(activeTool) {
                    case 'pencil':
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.beginPath();
                        ctx.moveTo(lastPos.x, lastPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        break;
                    case 'eraser':
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.beginPath();
                        ctx.moveTo(lastPos.x, lastPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        break;
                    case 'lasso':
                        lassoPoints.push(pos);
                        drawLassoPreview();
                        break;
                    case 'line':
                    case 'rectangle':
                    case 'circle':
                        drawShapePreview(pos);
                        break;
                }
                lastPos = pos;
            };

            const stopDrawing = (e) => {
                if (!isDrawing) return;
                isDrawing = false;
                const pos = getMousePos(e);
                const ctx = getActiveContext();
                
                clearCanvas(previewCtx);

                switch(activeTool) {
                    case 'line':
                        drawLine(ctx, shapeStartPos, pos);
                        break;
                    case 'rectangle':
                        drawRectangle(ctx, shapeStartPos, pos);
                        break;
                    case 'circle':
                        drawCircle(ctx, shapeStartPos, pos);
                        break;
                    case 'lasso':
                        applyLassoErase(ctx);
                        break;
                }

                if (activeTool !== 'polygon') {
                    updateCurrentLayerData();
                }
            };
            
            const handleCanvasClick = (e) => {
                if (activeTool === 'fill') {
                    saveState();
                    const pos = getMousePos(e);
                    floodFill(getActiveContext(), Math.round(pos.x), Math.round(pos.y), hexToRgba(colorPicker.value));
                    updateCurrentLayerData();
                }
            };
            
            const handleCanvasDblClick = (e) => {
                 if (activeTool === 'polygon' && polygonPoints.length > 1) {
                    saveState();
                    drawPolygon(getActiveContext(), polygonPoints, true);
                    polygonPoints = [];
                    clearCanvas(previewCtx);
                    updateCurrentLayerData();
                }
            };

            // Shape drawing logic
            const drawShapePreview = (currentPos) => {
                clearCanvas(previewCtx);
                previewCtx.lineWidth = brushSizeSlider.value;
                previewCtx.strokeStyle = colorPicker.value;
                switch (activeTool) {
                    case 'line': drawLine(previewCtx, shapeStartPos, currentPos); break;
                    case 'rectangle': drawRectangle(previewCtx, shapeStartPos, currentPos); break;
                    case 'circle': drawCircle(previewCtx, shapeStartPos, currentPos); break;
                }
            };

            const drawLine = (ctx, start, end) => {
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            };

            const drawRectangle = (ctx, start, end) => {
                ctx.beginPath();
                ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                ctx.stroke();
            };

            const drawCircle = (ctx, start, end) => {
                const radius = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                ctx.beginPath();
                ctx.arc(start.x, start.y, radius, 0, 2 * Math.PI);
                ctx.stroke();
            };
            
            const drawPolygonPreview = () => {
                if (polygonPoints.length < 2) return;
                clearCanvas(previewCtx);
                drawPolygon(previewCtx, polygonPoints, false);
            };

            const drawPolygon = (ctx, points, closePath) => {
                if (points.length < 2) return;
                ctx.lineWidth = brushSizeSlider.value;
                ctx.strokeStyle = colorPicker.value;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (closePath) {
                    ctx.closePath();
                }
                ctx.stroke();
            };
            
            const drawLassoPreview = () => {
                 clearCanvas(previewCtx);
                 previewCtx.strokeStyle = 'rgba(79, 70, 229, 0.8)';
                 previewCtx.lineWidth = 2;
                 previewCtx.setLineDash([5, 5]);
                 drawPolygon(previewCtx, lassoPoints, true);
                 previewCtx.setLineDash([]);
            };
            
            const applyLassoErase = (ctx) => {
                if(lassoPoints.length < 3) return;
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for(let i=1; i < lassoPoints.length; i++) {
                    ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                lassoPoints = [];
            };

            // Flood fill implementation
            function floodFill(ctx, x, y, fillColor) {
                const imageData = ctx.getImageData(0, 0, animationCanvas.width, animationCanvas.height);
                const { width, height, data } = imageData;
                const stack = [[x, y]];
                const targetColor = getColorAtPixel(data, width, x, y);

                if (colorsMatch(targetColor, fillColor)) return;

                while (stack.length) {
                    const [px, py] = stack.pop();
                    if (px < 0 || px >= width || py < 0 || py >= height) continue;

                    const currentColor = getColorAtPixel(data, width, px, py);
                    if (colorsMatch(currentColor, targetColor)) {
                        setColorAtPixel(data, width, px, py, fillColor);
                        stack.push([px + 1, py]);
                        stack.push([px - 1, py]);
                        stack.push([px, py + 1]);
                        stack.push([px, py - 1]);
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }

            const getColorAtPixel = (data, width, x, y) => {
                const i = (y * width + x) * 4;
                return [data[i], data[i+1], data[i+2], data[i+3]];
            };

            const setColorAtPixel = (data, width, x, y, color) => {
                const i = (y * width + x) * 4;
                data[i] = color[0];
                data[i+1] = color[1];
                data[i+2] = color[2];
                data[i+3] = color[3];
            };

            const colorsMatch = (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
            
            const hexToRgba = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return [r, g, b, 255]; // a = 255 (fully opaque)
            };

            // --- Undo/Redo ---
            const undo = () => {
                const history = getActiveHistory();
                if (history.undoStack.length > 0) {
                    const ctx = getActiveContext();
                    const currentState = ctx.getImageData(0, 0, animationCanvas.width, animationCanvas.height);
                    history.redoStack.push(currentState);
                    const lastState = history.undoStack.pop();
                    ctx.putImageData(lastState, 0, 0);
                    updateCurrentLayerData();
                    updateUndoRedoButtons();
                }
            };
            
            const redo = () => {
                const history = getActiveHistory();
                if (history.redoStack.length > 0) {
                    const ctx = getActiveContext();
                    const currentState = ctx.getImageData(0, 0, animationCanvas.width, animationCanvas.height);
                    history.undoStack.push(currentState);
                    const nextState = history.redoStack.pop();
                    ctx.putImageData(nextState, 0, 0);
                    updateCurrentLayerData();
                    updateUndoRedoButtons();
                }
            };

            const updateUndoRedoButtons = () => {
                const history = getActiveHistory();
                undoBtn.disabled = !history || history.undoStack.length === 0;
                redoBtn.disabled = !history || history.redoStack.length === 0;
            };

            // --- Timeline Management ---
            const addFrame = (data = null, atIndex = frames.length) => {
                const newFrame = {
                    data: data,
                    undoStack: [],
                    redoStack: [],
                };
                frames.splice(atIndex, 0, newFrame);
                renderTimeline();
                selectFrame(atIndex);
            };
            
            const duplicateFrame = (index) => {
                const frameToCopy = frames[index];
                if (!frameToCopy) return;
                addFrame(frameToCopy.data, index + 1);
            };

            const deleteFrame = (index) => {
                if (frames.length <= 1) return;
                frames.splice(index, 1);
                if (currentFrameIndex >= index) {
                    currentFrameIndex = Math.max(0, currentFrameIndex - 1);
                }
                renderTimeline();
                selectFrame(currentFrameIndex);
            };

            const selectFrame = (index) => {
                if(isPlaying) stopPlayback();
                
                updateCurrentLayerData(); // Save current work
                
                currentFrameIndex = index;
                
                // Load new frame's data onto canvas
                const frameData = frames[currentFrameIndex].data;
                clearCanvas(animCtx);
                if (frameData) {
                    const img = new Image();
                    img.onload = () => animCtx.drawImage(img, 0, 0);
                    img.src = frameData;
                }
                
                // Update UI
                document.querySelectorAll('.timeline-frame.active').forEach(f => f.classList.remove('active'));
                const frameEl = document.querySelector(`.timeline-frame[data-index='${index}']`);
                if (frameEl) frameEl.classList.add('active');

                drawOnionSkins();
                updateFrameCount();
                updateUndoRedoButtons();
            };

            const renderTimeline = () => {
                timeline.innerHTML = ''; // Clear existing timeline
                frames.forEach((frame, index) => {
                    const frameEl = document.createElement('div');
                    frameEl.className = 'timeline-frame bg-slate-800 rounded-lg w-32 h-20 flex-shrink-0 cursor-pointer overflow-hidden';
                    frameEl.dataset.index = index;
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 72;
                    canvas.className = "w-full h-full object-cover";
                    frameEl.appendChild(canvas);

                    const frameNumber = document.createElement('span');
                    frameNumber.className = 'absolute bottom-1 left-2 text-xs font-bold text-white bg-black bg-opacity-50 px-1 rounded';
                    frameNumber.textContent = index + 1;
                    frameEl.appendChild(frameNumber);
                    
                    const controls = document.createElement('div');
                    controls.className = 'frame-controls';
                    
                    const duplicateBtn = document.createElement('button');
                    duplicateBtn.className = 'frame-control-btn';
                    duplicateBtn.title = 'Duplicate Frame';
                    duplicateBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-files" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2zM2 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4z"/></svg>`;
                    duplicateBtn.onclick = (e) => { e.stopPropagation(); duplicateFrame(index); };
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'frame-control-btn';
                    deleteBtn.title = 'Delete Frame';
                    deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>`;
                    deleteBtn.onclick = (e) => { e.stopPropagation(); deleteFrame(index); };

                    controls.appendChild(duplicateBtn);
                    controls.appendChild(deleteBtn);
                    frameEl.appendChild(controls);

                    frameEl.addEventListener('click', () => selectFrame(index));
                    timeline.appendChild(frameEl);
                    updateTimelineThumbnail(index);
                });
                 updateFrameCount();
            };

            const updateTimelineThumbnail = (index) => {
                const frameEl = timeline.querySelector(`.timeline-frame[data-index='${index}']`);
                if (!frameEl) return;
                const canvas = frameEl.querySelector('canvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                clearCanvas(ctx);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const drawCompositeImage = () => {
                    if (uploadedBackgroundImage) {
                        ctx.drawImage(uploadedBackgroundImage, 0, 0, canvas.width, canvas.height);
                    }
                    if (backgroundData.data) {
                        const bgImg = new Image();
                        bgImg.onload = () => {
                            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
                             if (frames[index] && frames[index].data) {
                                const frameImg = new Image();
                                frameImg.onload = () => ctx.drawImage(frameImg, 0, 0, canvas.width, canvas.height);
                                frameImg.src = frames[index].data;
                            }
                        };
                        bgImg.src = backgroundData.data;
                    } else if (frames[index] && frames[index].data) {
                        const frameImg = new Image();
                        frameImg.onload = () => ctx.drawImage(frameImg, 0, 0, canvas.width, canvas.height);
                        frameImg.src = frames[index].data;
                    }
                }
                drawCompositeImage();
            };
            
            const updateCurrentLayerData = () => {
                if(activeLayer === 'animation' && frames[currentFrameIndex]){
                    frames[currentFrameIndex].data = animationCanvas.toDataURL();
                    updateTimelineThumbnail(currentFrameIndex);
                } else {
                    backgroundData.data = drawingBgCanvas.toDataURL();
                    renderTimeline(); // Redraw all thumbnails if bg changes
                }
            }

            // --- Onion Skinning ---
            const drawOnionSkins = () => {
                clearCanvas(onionBehindCtx);
                clearCanvas(onionAheadCtx);

                if (onionSkinCheckbox.checked) {
                    const drawSkin = (ctx, index) => {
                         if (index >= 0 && index < frames.length && frames[index].data) {
                            const img = new Image();
                            img.onload = () => {
                                ctx.globalAlpha = 0.3;
                                ctx.drawImage(img, 0, 0);
                                ctx.globalAlpha = 1.0;
                            };
                            img.src = frames[index].data;
                        }
                    };
                    drawSkin(onionBehindCtx, currentFrameIndex - 1);
                    drawSkin(onionAheadCtx, currentFrameIndex + 1);
                }
            };
            
            // --- Playback ---
            const togglePlayback = () => {
                isPlaying ? stopPlayback() : startPlayback();
            };

            const startPlayback = () => {
                isPlaying = true;
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                playPauseMobileBtn.innerHTML = pauseIcon.outerHTML;
                lastFrameTime = performance.now();
                updateCurrentLayerData(); // Save any pending drawing
                animationFrameId = requestAnimationFrame(playbackLoop);
            };

            const stopPlayback = () => {
                isPlaying = false;
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                playPauseMobileBtn.innerHTML = playIcon.outerHTML;
                cancelAnimationFrame(animationFrameId);
                selectFrame(currentFrameIndex); // Go back to the frame we were on
            };

            const playbackLoop = (currentTime) => {
                if (!isPlaying) return;
                
                const fps = fpsSlider.value;
                const frameInterval = 1000 / fps;
                const elapsed = currentTime - lastFrameTime;

                if (elapsed > frameInterval) {
                    lastFrameTime = currentTime - (elapsed % frameInterval);
                    currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                    
                    const frameData = frames[currentFrameIndex].data;
                    clearCanvas(animCtx);
                    if (frameData) {
                        const img = new Image();
                        img.onload = () => animCtx.drawImage(img, 0, 0);
                        img.src = frameData;
                    }
                    
                    document.querySelectorAll('.timeline-frame.active').forEach(f => f.classList.remove('active'));
                    const frameEl = document.querySelector(`.timeline-frame[data-index='${currentFrameIndex}']`);
                    if(frameEl) frameEl.classList.add('active');
                    updateFrameCount();
                }
                animationFrameId = requestAnimationFrame(playbackLoop);
            };

            // --- UI Updates ---
            const updateFrameCount = () => {
                frameCountEl.textContent = `${currentFrameIndex + 1} / ${frames.length}`;
                const duration = (frames.length) / fpsSlider.value;
                animationTimeEl.textContent = `${duration.toFixed(1)}s`;
            };

            const switchTool = (tool) => {
                polygonPoints = [];
                clearCanvas(previewCtx);

                toolButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));
                
                activeTool = tool;
                animationCanvas.style.cursor = tool === 'pan' ? 'grab' : 'crosshair';
            };
            
            const switchLayer = (layer) => {
                activeLayer = layer;
                animationLayerBtn.classList.toggle('active', layer === 'animation');
                backgroundLayerBtn.classList.toggle('active', layer === 'background');
                updateUndoRedoButtons();
            };
            
            // --- Zoom & Pan ---
            const applyTransform = () => {
                canvasContainer.style.transform = `translate(${transform.panX}px, ${transform.panY}px) scale(${transform.scale})`;
                zoomLevelDisplay.textContent = `${Math.round(transform.scale * 100)}%`;
            };

            const handleZoom = (e) => {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const wheel = e.deltaY < 0 ? 1 : -1;
                const zoom = Math.exp(wheel * zoomIntensity);

                const rect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const newScale = Math.max(0.1, Math.min(5, transform.scale * zoom));
                
                transform.panX -= (mouseX - transform.panX) * (newScale / transform.scale - 1);
                transform.panY -= (mouseY - transform.panY) * (newScale / transform.scale - 1);
                
                transform.scale = newScale;
                
                applyTransform();
            };

            const startPan = (e) => {
                 if(e.touches) e.preventDefault();
                 isPanning = true;
                 const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                 const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                 panStart.x = clientX - transform.panX;
                 panStart.y = clientY - transform.panY;
                 animationCanvas.style.cursor = 'grabbing';
            };
            
            const doPan = (e) => {
                 if (!isPanning) return;
                 if(e.touches) e.preventDefault();
                 const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                 const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                 transform.panX = clientX - panStart.x;
                 transform.panY = clientY - panStart.y;
                 applyTransform();
            };

            const stopPan = () => {
                 isPanning = false;
                 animationCanvas.style.cursor = activeTool === 'pan' ? 'grab' : 'crosshair';
            };
            
            const resetZoom = () => {
                const viewportRect = viewport.getBoundingClientRect();
                const scaleX = viewportRect.width / animationCanvas.width;
                const scaleY = viewportRect.height / animationCanvas.height;
                transform.scale = Math.min(scaleX, scaleY) * 0.95; 
                
                transform.panX = (viewportRect.width - (animationCanvas.width * transform.scale)) / 2;
                transform.panY = (viewportRect.height - (animationCanvas.height * transform.scale)) / 2;
                applyTransform();
            };

            // --- Background Handling ---
            const handleBgUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        uploadedBackgroundImage = new Image();
                        uploadedBackgroundImage.onload = () => {
                            clearCanvas(imageBgCtx);
                            imageBgCtx.drawImage(uploadedBackgroundImage, 0, 0, animationCanvas.width, animationCanvas.height);
                            renderTimeline();
                        };
                        uploadedBackgroundImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            
            const clearBackground = () => {
                uploadedBackgroundImage = null;
                backgroundData = { current: null, undoStack: [], redoStack: [] };
                clearCanvas(imageBgCtx);
                clearCanvas(drawingBgCtx);
                const blankCanvas = document.createElement('canvas');
                blankCanvas.width=animationCanvas.width; blankCanvas.height=animationCanvas.height;
                backgroundData.current = blankCanvas.toDataURL();
                renderTimeline();
                updateUndoRedoButtons();
            };

            // --- Save/Load Project ---
            const saveProject = () => {
                updateCurrentLayerData();
                const projectName = projectTitleEl.textContent.trim() || 'animation-project';
                const projectData = {
                    projectName,
                    frames: frames.map(f => f.data),
                    drawnBackground: backgroundData.data,
                    uploadedImage: uploadedBackgroundImage ? uploadedBackgroundImage.src : null,
                    fps: fpsSlider.value
                };

                const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const safeFilename = projectName.replace(/[^a-z0-9_.-]/gi, '_').toLowerCase();
                a.href = url;
                a.download = `${safeFilename}.anim`;
                a.click();
                URL.revokeObjectURL(url);
            };

            function loadProject(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const projectData = JSON.parse(event.target.result);
                            
                            clearBackground();
                            projectTitleEl.textContent = projectData.projectName || 'MovingLines';

                            frames = projectData.frames.map(frameData => ({
                                data: frameData, undoStack:[], redoStack:[]
                            }));
                            
                            if(projectData.drawnBackground) {
                                backgroundData.data = projectData.drawnBackground;
                                const bgImg = new Image();
                                bgImg.onload = () => drawingBgCtx.drawImage(bgImg, 0, 0);
                                bgImg.src = backgroundData.data;
                            }
                            
                            if(projectData.uploadedImage) {
                                uploadedBackgroundImage = new Image();
                                uploadedBackgroundImage.onload = () => imageBgCtx.drawImage(uploadedBackgroundImage, 0, 0);
                                uploadedBackgroundImage.src = projectData.uploadedImage;
                            }

                            fpsSlider.value = projectData.fps || 12;
                            fpsSliderMobile.value = projectData.fps || 12;
                            fpsValue.textContent = projectData.fps || 12;
                            fpsValueMobile.textContent = projectData.fps || 12;
                            
                            renderTimeline();
                            selectFrame(0);

                        } catch (error) {
                            console.error("Failed to load project file:", error);
                            alert("Invalid or corrupted project file.");
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            // --- Export ---
            const showLoading = (text) => {
                loadingText.textContent = text;
                loadingModal.classList.remove('hidden');
            };

            const hideLoading = () => {
                loadingModal.classList.add('hidden');
            };

            const createCompositeFrame = async (frameData) => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = animationCanvas.width;
                tempCanvas.height = animationCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                if (uploadedBackgroundImage) tempCtx.drawImage(uploadedBackgroundImage, 0, 0);
                if (backgroundData.data) {
                    await new Promise(res => {
                        const bgImg = new Image();
                        bgImg.onload = () => { tempCtx.drawImage(bgImg, 0, 0); res(); };
                        bgImg.src = backgroundData.data;
                    });
                }
                if (frameData) {
                     await new Promise(res => {
                        const frameImg = new Image();
                        frameImg.onload = () => { tempCtx.drawImage(frameImg, 0, 0); res(); };
                        frameImg.src = frameData;
                    });
                }
                return tempCanvas;
            };

            const exportAsWebM = async () => {
                updateCurrentLayerData(); // Save the current frame before exporting
                showLoading('Exporting WebM...');
                const stream = animationCanvas.captureStream(0);
                const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                const chunks = [];
                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${projectTitleEl.textContent.trim()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                    hideLoading();
                };

                recorder.start();

                const frameInterval = 1000 / fpsSlider.value;
                for (const frame of frames) {
                    const frameCanvas = await createCompositeFrame(frame.data);
                    clearCanvas(animCtx);
                    animCtx.drawImage(frameCanvas, 0, 0);
                    stream.getVideoTracks()[0].requestFrame();
                    await new Promise(resolve => setTimeout(resolve, frameInterval));
                }
                
                recorder.stop();
            };
            
            const exportAsAPNG = async () => {
                updateCurrentLayerData(); // Save the current frame before exporting
                showLoading('Exporting APNG...');
                const frameBuffers = [];
                const delays = [];
                const frameInterval = 1000 / fpsSlider.value;

                for (const frame of frames) {
                    const frameCanvas = await createCompositeFrame(frame.data);
                    const blob = await new Promise(resolve => frameCanvas.toBlob(resolve, 'image/png'));
                    const buffer = await blob.arrayBuffer();
                    frameBuffers.push(buffer);
                    delays.push(frameInterval);
                }

                const apng = APNG.encode(frameBuffers, delays);
                const blob = new Blob([apng], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectTitleEl.textContent.trim()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                hideLoading();
            };
            
            // --- Initialization ---
            const init = () => {
                // Set canvas sizes
                [imageBgCanvas, drawingBgCanvas, onionBehindCanvas, animationCanvas, onionAheadCanvas, previewCanvas].forEach(c => {
                    c.width = 1280;
                    c.height = 720;
                });

                // Event Listeners
                animationCanvas.addEventListener('mousedown', startDrawing);
                window.addEventListener('mousemove', draw);
                window.addEventListener('mouseup', stopDrawing);
                animationCanvas.addEventListener('mouseleave', stopDrawing);
                animationCanvas.addEventListener('click', handleCanvasClick);
                animationCanvas.addEventListener('dblclick', handleCanvasDblClick);
                
                animationCanvas.addEventListener('touchstart', startDrawing, {passive:false});
                window.addEventListener('touchmove', draw, {passive:false});
                window.addEventListener('touchend', stopDrawing);
                window.addEventListener('touchcancel', stopDrawing);

                addFrameBtn.addEventListener('click', () => addFrame(null, currentFrameIndex + 1));
                toolButtons.forEach(btn => btn.addEventListener('click', () => switchTool(btn.dataset.tool)));
                animationLayerBtn.addEventListener('click', () => switchLayer('animation'));
                backgroundLayerBtn.addEventListener('click', () => switchLayer('background'));

                undoBtn.addEventListener('click', undo);
                redoBtn.addEventListener('click', redo);

                colorPicker.addEventListener('input', (e) => {
                    const newColor = e.target.value;
                    document.querySelector('.color-swatch.active')?.classList.remove('active');
                    const existingSwatch = [...document.querySelectorAll('.color-swatch')].find(s => s.style.backgroundColor === newColor);
                    if (existingSwatch) existingSwatch.classList.add('active');
                });

                brushSizeSlider.addEventListener('input', (e) => brushSizeValue.textContent = e.target.value);
                onionSkinCheckbox.addEventListener('change', drawOnionSkins);
                
                // Sync FPS sliders
                const syncFps = (e) => {
                    fpsValue.textContent = e.target.value;
                    fpsSliderMobile.value = e.target.value;
                    fpsValueMobile.textContent = e.target.value;
                    fpsSlider.value = e.target.value;
                    updateFrameCount();
                };
                fpsSlider.addEventListener('input', syncFps);
                fpsSliderMobile.addEventListener('input', syncFps);

                playPauseBtn.addEventListener('click', togglePlayback);
                playPauseMobileBtn.addEventListener('click', togglePlayback);

                document.addEventListener('keydown', (e) => {
                    if (e.target.isContentEditable) return;
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') { e.preventDefault(); undo(); }
                        if (e.key === 'y') { e.preventDefault(); redo(); }
                    }
                     if (e.code === 'Space' && activeTool !== 'pan') {
                        e.preventDefault();
                        previousTool = activeTool;
                        switchTool('pan');
                        startPan(e); 
                    }
                });
                document.addEventListener('keyup', (e) => {
                     if (e.code === 'Space' && activeTool === 'pan') {
                        switchTool(previousTool);
                    }
                });
                
                // Zoom & Pan Listeners
                viewport.addEventListener('wheel', handleZoom);
                viewport.addEventListener('mousedown', (e) => {
                    if (activeTool === 'pan' || e.buttons === 4) { startPan(e); }
                });
                
                zoomInBtn.addEventListener('click', () => handleZoom({ preventDefault: () => {}, deltaY: -1, clientX: viewport.clientWidth / 2, clientY: viewport.clientHeight / 2 }));
                zoomOutBtn.addEventListener('click', () => handleZoom({ preventDefault: () => {}, deltaY: 1, clientX: viewport.clientWidth / 2, clientY: viewport.clientHeight / 2 }));
                resetZoomBtn.addEventListener('click', resetZoom);
                window.addEventListener('resize', resetZoom);
                
                // Modals & File IO
                saveProjectBtn.addEventListener('click', saveProject);
                loadProjectInput.addEventListener('change', loadProject);
                bgUploadInput.addEventListener('change', handleBgUpload);
                clearBgBtn.addEventListener('click', clearBackground);
                showInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
                closeInstructionsModalBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));
                openExportModalBtn.addEventListener('click', () => exportModal.classList.remove('hidden'));
                closeExportModalBtn.addEventListener('click', () => exportModal.classList.add('hidden'));
                exportWebmBtnModal.addEventListener('click', exportAsWebM);
                exportApngBtnModal.addEventListener('click', exportAsAPNG);

                // Initial setup
                playPauseMobileBtn.innerHTML = playIcon.outerHTML;
                PALETTE_COLORS.forEach((color, index) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-slate-600';
                    swatch.style.backgroundColor = color;
                    if (index === 0) { swatch.classList.add('active'); colorPicker.value = color; }
                    swatch.addEventListener('click', () => {
                        colorPicker.value = color;
                        document.querySelector('.color-swatch.active')?.classList.remove('active');
                        swatch.classList.add('active');
                    });
                    colorPalette.appendChild(swatch);
                });
                
                const blankCanvas = document.createElement('canvas');
                blankCanvas.width=1280; blankCanvas.height=720;
                backgroundData.current = blankCanvas.toDataURL();
                
                addFrame(blankCanvas.toDataURL());
                resetZoom();
            };

            init();
        });
    </script>
</body>
</html>


