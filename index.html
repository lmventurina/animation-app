<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MovingLines - 2D Animation Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .timeline-frame {
            border: 2px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .timeline-frame.active {
            border-color: #4f46e5; /* indigo-600 */
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.7);
        }
        .tool-button.active, .layer-button.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border-color: #6366f1; /* indigo-500 */
        }
        .loader {
            border: 4px solid #4b5563; /* gray-600 */
            border-radius: 50%;
            border-top: 4px solid #4f46e5; /* indigo-600 */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            height: 8px;
        }
        .timeline-container::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        .timeline-container::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }

        /* Viewport for Zoom/Pan */
        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            border-radius: 0.5rem;
             background-color: #4b5563; /* gray-600 as fallback */
        }

        .canvas-container {
            position: relative;
            width: 1280px; /* Fixed internal resolution */
            height: 720px;
            transform-origin: 0 0;
        }

        .base-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #onion-skin-canvas-behind,
        #onion-skin-canvas-ahead,
        #preview-canvas { /* preview canvas for shapes */
            pointer-events: none;
        }
        #image-bg-canvas {
             background-color: white;
        }
        /* Disabled button style */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .color-swatch {
            transition: transform 0.1s ease-in-out;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.active {
            box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5;
        }
        .header-btn {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .header-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        [contenteditable]:hover {
            background-color: #334155; /* slate-700 */
        }
        [contenteditable]:focus {
            background-color: #475569; /* slate-600 */
            outline: 2px solid #4f46e5; /* indigo-600 */
        }
    </style>
</head>
<body class="bg-slate-900 text-gray-300 flex flex-col h-screen overflow-hidden">
    <!-- Header -->
    <header class="bg-slate-800 shadow-md p-3 flex justify-between items-center z-20 border-b border-slate-700 flex-shrink-0">
        <h1 id="project-title" contenteditable="true" class="text-lg md:text-xl font-bold text-white whitespace-nowrap px-2 rounded-md outline-none" title="Click to rename">MovingLines</h1>
        <!-- Playback Controls -->
        <div class="hidden md:flex items-center gap-4 absolute left-1/2 -translate-x-1/2">
             <button id="play-pause" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-pause-fill hidden" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>
            </button>
            <div class="flex items-center gap-2">
                <label for="fps-slider" class="text-sm font-medium">FPS:</label>
                <input type="range" id="fps-slider" min="1" max="30" value="12" class="w-24 h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                <span id="fps-value" class="text-sm font-semibold w-6 text-center">12</span>
            </div>
        </div>
        <div class="flex items-center gap-2 md:gap-4">
            <button id="show-instructions" class="header-btn bg-gradient-to-br from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-bold py-2 px-3 md:px-4 rounded-lg text-sm">Help</button>
            <button id="save-project" class="header-btn bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16"><path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v4.5h2a.5.5 0 0 1 .354.854l-2.5 2.5a.5.5 0 0 1-.708 0l-2.5-2.5A.5.5 0 0 1 5.5 6.5h2V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/></svg>
                <span class="hidden md:inline">Save</span>
            </button>
            <label for="load-project-input" class="header-btn bg-gradient-to-br from-yellow-400 to-yellow-500 hover:from-yellow-500 hover:to-yellow-600 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2 cursor-pointer">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder2-open" viewBox="0 0 16 16"><path d="M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.958 0 1.76.746 1.97.684l.248-.06c.26-.06.58.11.732.358L8.5 3.5h5.5A1.5 1.5 0 0 1 15.5 5v.54L14.05 8.4a.5.5 0 0 1-.45.3H5.4a.5.5 0 0 1-.45-.3L3.5 5.54V5.5A1.5 1.5 0 0 1 2 4H1.5V3.5zM2 6h12v5a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6z"/><path d="M.5 4a.5.5 0 0 0 0 1h15a.5.5 0 0 0 0-1H.5z"/></svg>
                <span class="hidden md:inline">Load</span>
            </label>
            <input type="file" id="load-project-input" class="hidden" accept=".anim">
             <button id="export-webm-btn" class="header-btn bg-gradient-to-br from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                <span class="hidden md:inline">Export</span>
            </button>
        </div>
    </header>
    <!-- Main Content -->
    <div class="flex flex-col md:flex-row flex-grow overflow-hidden">
        <!-- Toolbar -->
        <aside class="w-full md:w-56 bg-slate-800 p-3 flex-shrink-0 flex flex-col gap-2 overflow-y-auto z-10 border-b md:border-b-0 md:border-r border-slate-700">
            <!-- Layers -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Layer</h3>
                 <div class="flex flex-col gap-2">
                    <button id="animation-layer-btn" class="layer-button active bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Animation</button>
                    <button id="background-layer-btn" class="layer-button bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Background</button>
                </div>
            </div>
            <!-- Tools -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Tool</h3>
                <div id="tools-container" class="grid grid-cols-4 gap-2">
                    <button data-tool="pencil" class="tool-button active p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Pencil">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>
                    </button>
                     <button data-tool="pan" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Pan (Hold Space)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M19,10.5C19,10.22 18.78,10 18.5,10H17V6.5C17,6.22 16.78,6 16.5,6C16.22,6 16,6.22 16,6.5V10H14V4.5C14,4.22 13.78,4 13.5,4C13.22,4 13,4.22 13,4.5V10H11V5.5C11,5.22 10.78,5 10.5,5C10.22,5 10,5.22 10,5.5V10H8.5C7.67,10 7,10.67 7,11.5V17H5.5C5.22,17 5,17.22 5,17.5C5,17.78 5.22,18 5.5,18H7V19.5C7,19.78 7.22,20 7.5,20C7.78,20 8,19.78 8,19.5V18H10.5C11.33,18 12,17.33 12,16.5V11H13.5V18.5C13.5,18.78 13.72,19 14,19C14.28,19 14.5,18.78 14.5,18.5V11H16V19C16,19.28 16.22,19.5 16.5,19.5C16.78,19.5 17,19.28 17,19V11.5C17,10.67 17.67,10 18.5,10H19V10.5Z" />
                        </svg>
                    </button>
                    <button data-tool="eraser" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Eraser">
                         <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm.66 11.34L3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/></svg>
                    </button>
                    <button data-tool="lasso" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Lasso Erase">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5">
                            <path d="M4.23223 15.7678C1.20573 12.7413 1.20573 7.75868 4.23223 4.73223C7.25873 1.70573 12.2413 1.70573 15.2678 4.73223C18.2943 7.75868 18.2943 12.7413 15.2678 15.7678L12.5 18.5L9.5 21.5L4.23223 15.7678Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"/>
                        </svg>
                    </button>
                    <button data-tool="fill" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Paint Bucket">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M16.56,8.94L7.62,0L6.21,1.41L8.59,3.79L3.44,8.94C2.85,9.53 2.85,10.47 3.44,11.06L8.94,16.56C9.23,16.85 9.62,17 10,17C10.38,17 10.77,16.85 11.06,16.56L16.56,11.06C17.15,10.47 17.15,9.53 16.56,8.94M5.21,10L10,5.21L14.79,10M19,12C19,13.1 18.6,14.12 18,15V19C18,20.1 17.1,21 16,21H8C6.9,21 6,20.1 6,19V17H16.76L18.84,14.92C18.93,14 19,13 19,12Z" />
                        </svg>
                    </button>
                     <button data-tool="line" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Line">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.5 19.5L19.5 4.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="rectangle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Rectangle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="circle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Circle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="polygon" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Polygon (Double-click to finish)">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2L2 8L5 20H19L22 8L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <button id="undo-btn" class="p-2 rounded-lg flex justify-center items-center gap-2 bg-slate-700 hover:bg-slate-600 border-2 border-slate-600 text-sm" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
                        </svg>
                        <span>Undo</span>
                    </button>
                    <button id="redo-btn" class="p-2 rounded-lg flex justify-center items-center gap-2 bg-slate-700 hover:bg-slate-600 border-2 border-slate-600 text-sm" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                        <span>Redo</span>
                    </button>
                </div>
            </div>
            <!-- Brush Size -->
            <div>
                <label for="brush-size" class="text-xs font-semibold text-gray-400 uppercase">Brush Size</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="brush-size-value" class="text-sm font-semibold w-6 text-center">5</span>
                </div>
            </div>
            <!-- Color -->
            <div>
                <label for="color-picker" class="text-xs font-semibold mb-1 text-gray-400 uppercase">Color</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="color" id="color-picker" value="#000000" class="w-10 h-10 rounded-lg cursor-pointer border-2 border-slate-600">
                    <div id="color-palette" class="grid grid-cols-5 gap-1 flex-1">
                        <!-- Color swatches will be inserted here -->
                    </div>
                </div>
            </div>
            <!-- Onion Skin -->
            <div class="flex justify-center">
                <label for="onion-skin" class="flex items-center cursor-pointer select-none">
                    <input type="checkbox" id="onion-skin" class="h-5 w-5 rounded border-gray-500 text-indigo-500 focus:ring-indigo-600 bg-slate-700">
                    <span class="ml-3 text-base font-bold">Onion Skin</span>
                </label>
            </div>
            <!-- Background Options -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Background Options</h3>
                <div class="flex flex-col gap-2">
                    <label for="bg-upload-input" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-sm text-center cursor-pointer">Upload Image</label>
                    <input type="file" id="bg-upload-input" class="hidden" accept="image/*">
                    <button id="clear-bg-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg text-sm">Clear Background</button>
                </div>
            </div>
             <!-- Playback for Mobile -->
             <div class="md:hidden">
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Playback</h3>
                <div class="flex items-center justify-center gap-4 mt-2">
                    <button id="play-pause-mobile" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                         <!-- Icons will be cloned here by JS -->
                    </button>
                </div>
                 <div class="flex items-center gap-2 mt-2">
                    <label for="fps-slider-mobile" class="text-sm font-medium">FPS:</label>
                    <input type="range" id="fps-slider-mobile" min="1" max="30" value="12" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="fps-value-mobile" class="text-sm font-semibold w-6 text-center">12</span>
                </div>
            </div>
        </aside>
        <!-- Canvas -->
        <main class="flex-grow flex items-center justify-center p-2 md:p-4 bg-slate-900 overflow-hidden relative">
            <div id="viewport" class="shadow-xl">
                 <div class="canvas-container">
                    <canvas id="image-bg-canvas" class="base-canvas"></canvas>
                    <canvas id="drawing-bg-canvas" class="base-canvas"></canvas>
                    <canvas id="onion-skin-canvas-behind" class="base-canvas"></canvas>
                    <canvas id="animation-canvas" class="base-canvas"></canvas>
                    <canvas id="onion-skin-canvas-ahead" class="base-canvas"></canvas>
                    <canvas id="preview-canvas" class="base-canvas"></canvas>
                </div>
            </div>
            <!-- Zoom Controls -->
            <div class="absolute bottom-4 left-4 bg-slate-800 p-2 rounded-lg shadow-lg flex items-center gap-2 border border-slate-700 z-10">
                <button id="zoom-out-btn" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 rounded-md font-bold text-lg">-</button>
                <span id="zoom-level-display" class="text-sm font-semibold w-12 text-center">100%</span>
                <button id="zoom-in-btn" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 rounded-md font-bold text-lg">+</button>
                <button id="reset-zoom-btn" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 rounded-md" title="Reset Zoom">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-fullscreen-exit" viewBox="0 0 16 16"><path d="M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5zm5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5zM0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zm10 0a.5.5 0 0 1 .5-.5h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 1 0v4A1.5 1.5 0 0 1 14.5 10h-4a.5.5 0 0 1-.5-.5z"/></svg>
                </button>
            </div>
        </main>
    </div>
    <!-- Timeline -->
    <footer class="bg-slate-800 shadow-inner p-3 z-20 border-t border-slate-700 flex-shrink-0">
        <div class="relative flex justify-center items-center mb-2">
            <div class="absolute left-0">
                <h3 class="text-sm font-semibold text-gray-400 uppercase">Timeline</h3>
                <div class="flex items-center gap-4 mt-1">
                    <span id="frame-count" class="text-sm text-gray-400 font-mono">1 / 1</span>
                    <span id="animation-time" class="text-sm text-gray-400 font-mono">0.0s</span>
                </div>
            </div>
            <button id="add-frame" class="bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-4 rounded-lg text-sm flex items-center gap-2" title="Add New Frame">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
                </svg>
                <span>Add Frame</span>
            </button>
        </div>
        <div class="w-full overflow-y-auto pb-2 timeline-container max-h-60">
            <div id="timeline" class="flex flex-wrap items-start gap-2 p-2 bg-slate-700 rounded-lg min-h-28">
                 <!-- Add Frame button has been moved up -->
            </div>
        </div>
    </footer>
    
    <!-- Modal for loading spinner -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
        <div class="bg-slate-800 p-8 rounded-lg shadow-xl text-center border border-slate-700">
            <div class="loader mx-auto"></div>
            <p id="loading-text" class="mt-4 text-lg font-medium text-white">Generating...</p>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 text-white p-8 rounded-lg shadow-xl max-w-2xl w-full border border-slate-700">
            <h2 class="text-2xl font-bold mb-6 text-center">How to Use the Animation Tool</h2>
            <ol class="list-decimal list-inside space-y-3 text-gray-300">
                <li><b>Layers:</b> Switch between drawing on the 'Animation' layer (for moving parts) and the 'Background' layer (for static scenery).</li>
                <li><b>Tools:</b> Select a tool like Pencil, Eraser, Lasso, Shapes, or Polygon from the sidebar. For the Polygon tool, click to place points and double-click to finish the shape.</li>
                <li><b>Undo/Redo:</b> Use the undo/redo buttons in the sidebar or press <code>Ctrl+Z</code> / <code>Ctrl+Y</code>.</li>
                <li><b>Save/Load Project:</b> Use the 'Save' and 'Load' buttons to save your progress as a <code>.anim</code> file and open it again later.</li>
                <li><b>Rename Project:</b> Click the project title in the header (e.g., "MovingLines") to give your animation a custom name. This name is used when saving.</li>
                <li><b>Background Options:</b> You can either draw your own background on the background layer or upload an image using the 'Upload Image' button.</li>
                <li><b>Add & Duplicate Frames:</b> Use the <span class="text-green-400">'+'</span> button in the timeline to add a new frame. Hover over a frame to find the copy icon to duplicate it.</li>
                <li><b>Onion Skin:</b> Check this box in the toolbar to see faint outlines of your previous and *next* drawings, which helps with smooth animation.</li>
                <li><b>Play & Adjust FPS:</b> Use the play button and <span class="text-yellow-400">FPS</span> slider in the toolbar to preview your animation.</li>
                <li><b>Export:</b> When you're finished, use the 'Export' button to save your animation as a downloadable .webm video.</li>
            </ol>
            <div class="mt-8 text-center">
                <button id="close-instructions-modal" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-8 rounded-lg">Got it!</button>
            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const viewport = document.getElementById('viewport');
            const canvasContainer = document.querySelector('.canvas-container');
            const imageBgCanvas = document.getElementById('image-bg-canvas');
            const drawingBgCanvas = document.getElementById('drawing-bg-canvas');
            const onionBehindCanvas = document.getElementById('onion-skin-canvas-behind');
            const animationCanvas = document.getElementById('animation-canvas');
            const onionAheadCanvas = document.getElementById('onion-skin-canvas-ahead');
            const previewCanvas = document.getElementById('preview-canvas');
            const animCtx = animationCanvas.getContext('2d', { willReadFrequently: true });
            const imageBgCtx = imageBgCanvas.getContext('2d');
            const drawingBgCtx = drawingBgCanvas.getContext('2d');
            const onionBehindCtx = onionBehindCanvas.getContext('2d');
            const onionAheadCtx = onionAheadCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            // --- DOM Elements ---
            const projectTitleEl = document.getElementById('project-title');
            const animationLayerBtn = document.getElementById('animation-layer-btn');
            const backgroundLayerBtn = document.getElementById('background-layer-btn');
            const toolsContainer = document.getElementById('tools-container');
            const toolButtons = document.querySelectorAll('.tool-button');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const colorPicker = document.getElementById('color-picker');
            const colorPalette = document.getElementById('color-palette');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const onionSkinCheckbox = document.getElementById('onion-skin');
            const addFrameBtn = document.getElementById('add-frame');
            const timeline = document.getElementById('timeline');
            const animationTimeEl = document.getElementById('animation-time');
            const frameCountEl = document.getElementById('frame-count');
            // Desktop Playback
            const playPauseBtn = document.getElementById('play-pause');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const fpsSlider = document.getElementById('fps-slider');
            const fpsValue = document.getElementById('fps-value');
            // Mobile Playback
            const playPauseMobileBtn = document.getElementById('play-pause-mobile');
            const fpsSliderMobile = document.getElementById('fps-slider-mobile');
            const fpsValueMobile = document.getElementById('fps-value-mobile');
            // Zoom Controls
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const resetZoomBtn = document.getElementById('reset-zoom-btn');
            const zoomLevelDisplay = document.getElementById('zoom-level-display');
            // Export controls
            const exportWebmBtn = document.getElementById('export-webm-btn');
            
            const loadingModal = document.getElementById('loading-modal');
            const loadingText = document.getElementById('loading-text');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsModalBtn = document.getElementById('close-instructions-modal');
            const showInstructionsBtn = document.getElementById('show-instructions');
            const saveProjectBtn = document.getElementById('save-project');
            const loadProjectInput = document.getElementById('load-project-input');
            const bgUploadInput = document.getElementById('bg-upload-input');
            const clearBgBtn = document.getElementById('clear-bg-btn');
            // --- State ---
            let frames = [];
            let backgroundData = {
                current: null,
                undoStack: [],
                redoStack: []
            };
            let currentFrameIndex = 0;
            let isDrawing = false;
            let activeTool = 'pencil';
            let previousTool = 'pencil';
            let activeLayer = 'animation'; // 'animation' or 'background'
            let shapeStartPos = null;
            let polygonPoints = [];
            let isPlaying = false;
            let animationFrameId;
            let lastFrameTime = 0;
            let uploadedBackgroundImage = null;
            let lassoPoints = [];

            // --- Zoom & Pan State ---
            let zoomLevel = 1.0;
            let panOffset = { x: 0, y: 0 };
            let isPanning = false;
            let lastPanPosition = { x: 0, y: 0 };


            const paletteColors = [
                '#ffffff', '#c2c2c2', '#898989', '#505050', '#000000',
                '#ff5b5b', '#ff985b', '#ffff5b', '#98ff5b', '#5bff98',
                '#5bffff', '#5b98ff', '#985bff', '#ff5b98', '#ff5bff'
            ];

            function loadProjectData(projectData) {
                if (!projectData.frames) throw new Error('Invalid project file');
                projectTitleEl.textContent = projectData.projectName || 'MovingLines';
                frames = projectData.frames.map(frameDataURL => ({
                    current: frameDataURL, undoStack: [], redoStack: [],
                }));
                backgroundData = {
                    current: projectData.drawnBackground || drawingBgCanvas.toDataURL(),
                    undoStack: [], redoStack: []
                };
                currentFrameIndex = 0;
                const loadVisuals = () => {
                    renderTimeline();
                    redrawAll();
                    updateUndoRedoButtons();
                    updateTimelineInfo();
                };
                if (projectData.uploadedImage) {
                    const img = new Image();
                    img.onload = () => { uploadedBackgroundImage = img; loadVisuals(); };
                    img.src = projectData.uploadedImage;
                } else {
                    uploadedBackgroundImage = null; loadVisuals();
                }
            }

            // --- Canvas Setup ---
            function initialCanvasSetup() {
                // Set fixed internal resolution on all canvases
                 [imageBgCanvas, drawingBgCanvas, onionBehindCanvas, animationCanvas, onionAheadCanvas, previewCanvas].forEach(c => {
                    c.width = 1280;
                    c.height = 720;
                });
                 if (!backgroundData.current) {
                    backgroundData.current = drawingBgCanvas.toDataURL();
                }
                fitCanvasToViewport();
                redrawAll();
            }

            function fitCanvasToViewport() {
                const viewportRect = viewport.getBoundingClientRect();
                const canvasAspectRatio = 16 / 9;
                const viewportAspectRatio = viewportRect.width / viewportRect.height;

                let newZoom;
                if (viewportAspectRatio > canvasAspectRatio) {
                    // Viewport is wider than canvas
                    newZoom = viewportRect.height / 720;
                } else {
                    // Viewport is taller than canvas
                    newZoom = viewportRect.width / 1280;
                }
                
                zoomLevel = newZoom;
                panOffset.x = (viewportRect.width - (1280 * zoomLevel)) / 2;
                panOffset.y = (viewportRect.height - (720 * zoomLevel)) / 2;
                updateCanvasTransform();
            }


             function redrawAll() {
                loadFrame(currentFrameIndex);
                loadBackground();
                renderOnionSkins();
                frames.forEach((_, i) => updateTimelineThumbnail(i));
            }
            // --- History (Undo/Redo) ---
            function getActiveHistory() {
                return activeLayer === 'animation' ? frames[currentFrameIndex] : backgroundData;
            }
            function pushUndoState() {
                const history = getActiveHistory();
                if (!history) return;
                history.undoStack.push(history.current);
                history.redoStack = []; // Clear redo stack on new action
                if (history.undoStack.length > 30) {
                     history.undoStack.shift();
                }
                updateUndoRedoButtons();
            }
            function undo() {
                const history = getActiveHistory();
                if (!history || history.undoStack.length === 0) return;
                history.redoStack.push(history.current);
                history.current = history.undoStack.pop();
                const targetCtx = activeLayer === 'animation' ? animCtx : drawingBgCtx;
                const img = new Image();
                img.onload = () => {
                    clearCanvas(targetCtx);
                    targetCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height);
                    if (activeLayer === 'animation') {
                        updateTimelineThumbnail(currentFrameIndex);
                        renderOnionSkins();
                    }
                };
                img.src = history.current;
                updateUndoRedoButtons();
            }
            function redo() {
                const history = getActiveHistory();
                if (!history || history.redoStack.length === 0) return;
                history.undoStack.push(history.current);
                history.current = history.redoStack.pop();
                const targetCtx = activeLayer === 'animation' ? animCtx : drawingBgCtx;
                const img = new Image();
                img.onload = () => {
                    clearCanvas(targetCtx);
                    targetCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height);
                     if (activeLayer === 'animation') {
                        updateTimelineThumbnail(currentFrameIndex);
                        renderOnionSkins();
                    }
                };
                img.src = history.current;
                updateUndoRedoButtons();
            }
            function updateUndoRedoButtons() {
                const history = getActiveHistory();
                if (!history) {
                    undoBtn.disabled = true;
                    redoBtn.disabled = true;
                    return;
                };
                undoBtn.disabled = history.undoStack.length === 0;
                redoBtn.disabled = history.redoStack.length === 0;
            }

            // --- Drawing Logic ---
            function getMousePos(e) {
                const rect = viewport.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                // Translate viewport coordinates to canvas coordinates
                const canvasX = (clientX - rect.left - panOffset.x) / zoomLevel;
                const canvasY = (clientY - rect.top - panOffset.y) / zoomLevel;

                return {
                    x: canvasX,
                    y: canvasY
                };
            }

            function getActiveContext() {
                return activeLayer === 'animation' ? animCtx : drawingBgCtx;
            }

            function startDrawing(e) {
                if (e.touches) e.preventDefault();
                
                if (activeTool === 'pan') {
                    isPanning = true;
                    lastPanPosition.x = e.clientX;
                    lastPanPosition.y = e.clientY;
                    viewport.style.cursor = 'grabbing';
                    return;
                }
                
                const pos = getMousePos(e);

                if (activeTool === 'polygon') {
                    isDrawing = false;
                    if (polygonPoints.length === 0) {
                        pushUndoState();
                    }
                    polygonPoints.push(pos);
                    drawPolygonPreview(pos);
                    return;
                }

                isDrawing = true;
                const currentCtx = getActiveContext();

                if (['pencil', 'eraser'].includes(activeTool)) {
                    pushUndoState();
                    currentCtx.beginPath();
                    currentCtx.moveTo(pos.x, pos.y);
                    draw(e);
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    shapeStartPos = pos;
                } else if (activeTool === 'lasso') {
                    lassoPoints = [pos];
                    clearCanvas(previewCtx);
                } else if (activeTool === 'fill') {
                    isDrawing = false;
                    pushUndoState();
                    floodFill(pos.x, pos.y);
                }
            }

            function draw(e) {
                if(isPanning) {
                    const dx = e.clientX - lastPanPosition.x;
                    const dy = e.clientY - lastPanPosition.y;
                    panOffset.x += dx;
                    panOffset.y += dy;
                    lastPanPosition.x = e.clientX;
                    lastPanPosition.y = e.clientY;
                    updateCanvasTransform();
                    return;
                }


                const pos = getMousePos(e);
                if (activeTool === 'polygon' && polygonPoints.length > 0) {
                    drawPolygonPreview(pos);
                }

                if (!isDrawing) return;
                if (e.touches) e.preventDefault();
                
                const currentCtx = getActiveContext();
                if (['pencil', 'eraser'].includes(activeTool)) {
                    currentCtx.lineWidth = brushSizeSlider.value / zoomLevel;
                    currentCtx.lineCap = 'round';
                    currentCtx.lineJoin = 'round';
                    currentCtx.globalCompositeOperation = activeTool === 'eraser' ? 'destination-out' : 'source-over';
                    currentCtx.strokeStyle = colorPicker.value;
                    currentCtx.lineTo(pos.x, pos.y);
                    currentCtx.stroke();
                    currentCtx.beginPath();
                    currentCtx.moveTo(pos.x, pos.y);
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    drawShapePreview(pos);
                } else if (activeTool === 'lasso') {
                    lassoPoints.push(pos);
                    drawLassoPath();
                }
            }
            function stopDrawing(e) {
                if(isPanning) {
                    isPanning = false;
                    viewport.style.cursor = 'grab';
                    return;
                }

                if (!isDrawing) return;
                isDrawing = false;
                const currentCtx = getActiveContext();
                if (['pencil', 'eraser'].includes(activeTool)) {
                    currentCtx.beginPath();
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    pushUndoState();
                    drawShape(getMousePos(e));
                    shapeStartPos = null;
                } else if (activeTool === 'lasso') {
                    if (lassoPoints.length > 2) {
                        pushUndoState();
                        applyLassoDelete();
                    }
                    lassoPoints = [];
                    clearCanvas(previewCtx);
                }
                if (activeLayer === 'animation') {
                    saveFrame();
                } else {
                    saveBackground();
                }
            }
            // --- Shape Drawing Logic ---
            function drawShapePreview(currentPos) {
                clearCanvas(previewCtx);
                previewCtx.lineWidth = brushSizeSlider.value / zoomLevel;
                previewCtx.strokeStyle = colorPicker.value;
                previewCtx.beginPath();
                const start = shapeStartPos;
                const end = currentPos;
                if (activeTool === 'line') {
                    previewCtx.moveTo(start.x, start.y);
                    previewCtx.lineTo(end.x, end.y);
                } else if (activeTool === 'rectangle') {
                    previewCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (activeTool === 'circle') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    previewCtx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                }
                previewCtx.stroke();
            }
            function drawShape(endPos) {
                clearCanvas(previewCtx);
                const currentCtx = getActiveContext();
                currentCtx.lineWidth = brushSizeSlider.value / zoomLevel;
                currentCtx.strokeStyle = colorPicker.value;
                currentCtx.lineCap = 'round';
                currentCtx.lineJoin = 'round';
                currentCtx.globalCompositeOperation = 'source-over';
                currentCtx.beginPath();
                const start = shapeStartPos;
                const end = endPos;
                if (activeTool === 'line') {
                    currentCtx.moveTo(start.x, start.y);
                    currentCtx.lineTo(end.x, end.y);
                } else if (activeTool === 'rectangle') {
                    currentCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (activeTool === 'circle') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    currentCtx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                }
                currentCtx.stroke();
            }
            
            // --- Polygon Tool Logic ---
            function drawPolygonPreview(currentPos) {
                clearCanvas(previewCtx);
                if (polygonPoints.length === 0) return;

                previewCtx.lineWidth = brushSizeSlider.value / zoomLevel;
                previewCtx.strokeStyle = colorPicker.value;
                previewCtx.lineCap = 'round';
                previewCtx.lineJoin = 'round';
                previewCtx.beginPath();
                previewCtx.moveTo(polygonPoints[0].x, polygonPoints[0].y);

                for (let i = 1; i < polygonPoints.length; i++) {
                    previewCtx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                }
                if (currentPos) {
                    previewCtx.lineTo(currentPos.x, currentPos.y);
                }
                previewCtx.stroke();
            }

            function finishPolygon() {
                if (polygonPoints.length < 2) {
                    polygonPoints = [];
                    clearCanvas(previewCtx);
                    const history = getActiveHistory();
                    if(history && history.undoStack.length > 0) {
                         history.undoStack.pop();
                         updateUndoRedoButtons();
                    }
                    return;
                }

                const currentCtx = getActiveContext();
                currentCtx.lineWidth = brushSizeSlider.value / zoomLevel;
                currentCtx.strokeStyle = colorPicker.value;
                currentCtx.lineCap = 'round';
                currentCtx.lineJoin = 'round';
                currentCtx.globalCompositeOperation = 'source-over';
                currentCtx.beginPath();
                currentCtx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                for (let i = 1; i < polygonPoints.length; i++) {
                    currentCtx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                }
                currentCtx.closePath();
                currentCtx.stroke();

                polygonPoints = [];
                clearCanvas(previewCtx);

                if (activeLayer === 'animation') saveFrame();
                else saveBackground();
            }

            // --- Paint Bucket (Fill) Logic ---
            function floodFill(startX, startY) {
                const currentCtx = getActiveContext();
                const canvasWidth = animationCanvas.width;
                const canvasHeight = animationCanvas.height;
                const imageData = currentCtx.getImageData(0, 0, canvasWidth, canvasHeight);
                const data = imageData.data;

                const startPos = (Math.round(startY) * canvasWidth + Math.round(startX)) * 4;
                const startR = data[startPos];
                const startG = data[startPos + 1];
                const startB = data[startPos + 2];
                const startA = data[startPos + 3];

                const fillHex = colorPicker.value;
                const fillR = parseInt(fillHex.slice(1, 3), 16);
                const fillG = parseInt(fillHex.slice(3, 5), 16);
                const fillB = parseInt(fillHex.slice(5, 7), 16);

                if (startR === fillR && startG === fillG && startB === fillB) {
                    return;
                }
                
                const pixelStack = [[Math.round(startX), Math.round(startY)]];

                while (pixelStack.length) {
                    const newPos = pixelStack.pop();
                    const x = newPos[0];
                    let y = newPos[1];
                    let pixelPos = (y * canvasWidth + x) * 4;
                    while (y-- >= 0 && matchStartColor(pixelPos)) {
                        pixelPos -= canvasWidth * 4;
                    }
                    pixelPos += canvasWidth * 4;
                    ++y;

                    let reachLeft = false;
                    let reachRight = false;
                    while (y++ < canvasHeight - 1 && matchStartColor(pixelPos)) {
                        colorPixel(pixelPos);
                        if (x > 0) {
                            if (matchStartColor(pixelPos - 4)) {
                                if (!reachLeft) {
                                    pixelStack.push([x - 1, y]);
                                    reachLeft = true;
                                }
                            } else if (reachLeft) {
                                reachLeft = false;
                            }
                        }

                        if (x < canvasWidth - 1) {
                            if (matchStartColor(pixelPos + 4)) {
                                if (!reachRight) {
                                    pixelStack.push([x + 1, y]);
                                    reachRight = true;
                                }
                            } else if (reachRight) {
                                reachRight = false;
                            }
                        }
                        pixelPos += canvasWidth * 4;
                    }
                }
                currentCtx.putImageData(imageData, 0, 0);

                if (activeLayer === 'animation') saveFrame();
                else saveBackground();

                function matchStartColor(pixelPos) {
                    const r = data[pixelPos];
                    const g = data[pixelPos + 1];
                    const b = data[pixelPos + 2];
                    const a = data[pixelPos + 3];
                    return r === startR && g === startG && b === startB && a === startA;
                }

                function colorPixel(pixelPos) {
                    data[pixelPos] = fillR;
                    data[pixelPos + 1] = fillG;
                    data[pixelPos + 2] = fillB;
                    data[pixelPos + 3] = 255;
                }
            }


             // --- Lasso Logic ---
            function drawLassoPath() {
                if (lassoPoints.length < 2) return;
                clearCanvas(previewCtx);
                previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                previewCtx.lineWidth = 2;
                previewCtx.setLineDash([6, 6]);
                previewCtx.beginPath();
                previewCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    previewCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                previewCtx.stroke();
                previewCtx.setLineDash([]);
            }
            function applyLassoDelete() {
                const currentCtx = getActiveContext();
                currentCtx.save();
                currentCtx.beginPath();
                currentCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    currentCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                currentCtx.closePath();
                currentCtx.clip();
                currentCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                currentCtx.restore();
            }
            // --- Project Save/Load ---
            function saveProjectToFile() {
                const projectName = projectTitleEl.textContent.trim() || 'animation-project';
                const projectData = {
                    projectName: projectName,
                    frames: frames.map(f => f.current),
                    drawnBackground: backgroundData.current,
                    uploadedImage: uploadedBackgroundImage ? uploadedBackgroundImage.src : null,
                };
                const jsonString = JSON.stringify(projectData);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const safeFilename = projectName.replace(/[^a-z0-9_.-]/gi, '_').toLowerCase();
                a.href = url;
                a.download = `${safeFilename}.anim`;
                a.click();
                URL.revokeObjectURL(url);
            }
            function loadProjectFromFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        loadProjectData(projectData);
                    } catch (error) {
                        console.error("Error loading project:", error);
                        alert('Could not load project file.');
                    }
                };
                reader.readAsText(file);
                e.target.value = null;
            }
            // --- Frame Management ---
            function saveFrame() {
                if (!frames[currentFrameIndex]) return;
                frames[currentFrameIndex].current = animationCanvas.toDataURL();
                updateTimelineThumbnail(currentFrameIndex);
            }
            function loadFrame(index) {
                clearCanvas(animCtx);
                if (index < 0 || index >= frames.length) return;
                const img = new Image();
                img.onload = () => { animCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height); };
                img.src = frames[index].current;
            }
            function saveBackground() {
                backgroundData.current = drawingBgCanvas.toDataURL();
            }
            function loadBackground() {
                 clearCanvas(drawingBgCtx);
                 if (!backgroundData.current) return;
                 const img = new Image();
                 img.onload = () => { drawingBgCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height); };
                 img.src = backgroundData.current;
            }

            function clearCanvas(context) {
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            }
            // --- Timeline UI ---
            function renderTimeline() {
                const frameElements = timeline.querySelectorAll('.relative.flex-shrink-0.group');
                frameElements.forEach(el => el.remove());
                frames.forEach((_, index) => {
                    const frameContainer = createFrameElement(index);
                    timeline.appendChild(frameContainer);
                });
                frames.forEach((_, index) => { updateTimelineThumbnail(index); });
                updateActiveFrame();
            }
            function createFrameElement(index) {
                const frameContainer = document.createElement('div');
                frameContainer.className = 'relative flex-shrink-0 group';
                const frameElement = document.createElement('canvas');
                frameElement.className = 'timeline-frame h-24 w-40 bg-white rounded-lg cursor-pointer border-2 border-slate-600';
                frameElement.dataset.index = index;
                frameContainer.appendChild(frameElement);
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.className = 'absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full h-6 w-6 flex items-center justify-center font-bold opacity-0 group-hover:opacity-100 transition-opacity';
                deleteBtn.title = 'Delete Frame';
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteFrame(index); };
                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-files" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg>';
                copyBtn.className = 'absolute top-0 left-0 -mt-2 -ml-2 bg-blue-500 text-white rounded-full h-6 w-6 flex items-center justify-center font-bold opacity-0 group-hover:opacity-100 transition-opacity';
                copyBtn.title = 'Duplicate Frame';
                copyBtn.onclick = (e) => { e.stopPropagation(); copyFrame(index); };
                frameContainer.appendChild(deleteBtn);
                frameContainer.appendChild(copyBtn);
                frameElement.addEventListener('click', () => {
                    if (isPlaying) return;
                    if(activeLayer === 'animation') saveFrame(); else saveBackground();
                    currentFrameIndex = index;
                    loadFrame(index);
                    updateActiveFrame();
                    renderOnionSkins();
                    updateUndoRedoButtons();
                });
                return frameContainer;
            }
            function updateTimelineThumbnail(index) {
                const thumbCanvas = timeline.querySelector(`canvas[data-index='${index}']`);
                if (!thumbCanvas || !frames[index] || !frames[index].current) return;
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCanvas.width = 160; // Fixed thumbnail size
                thumbCanvas.height = 90;
                const img = new Image();
                img.onload = () => {
                    thumbCtx.fillStyle = 'white';
                    thumbCtx.fillRect(0,0,thumbCanvas.width, thumbCanvas.height);
                    thumbCtx.drawImage(img, 0, 0, thumbCanvas.width, thumbCanvas.height);
                };
                img.src = frames[index].current;
            }
            function updateActiveFrame() {
                timeline.querySelectorAll('.timeline-frame').forEach((el, i) => {
                    el.classList.toggle('active', i === currentFrameIndex);
                });
                updateTimelineInfo();
            }
            function addNewFrame() {
                saveFrame();
                const newCanvas = document.createElement('canvas');
                newCanvas.width = animationCanvas.width; newCanvas.height = animationCanvas.height;
                const newFrame = {
                    current: newCanvas.toDataURL(),
                    undoStack: [],
                    redoStack: []
                };
                frames.splice(currentFrameIndex + 1, 0, newFrame);
                currentFrameIndex++;
                loadFrame(currentFrameIndex);
                renderTimeline();
                renderOnionSkins();
                updateUndoRedoButtons();
                updateTimelineInfo();
            }
            function deleteFrame(index) {
                if (frames.length <= 1) return;
                frames.splice(index, 1);
                currentFrameIndex = Math.max(0, currentFrameIndex >= index ? currentFrameIndex - 1 : currentFrameIndex);
                loadFrame(currentFrameIndex);
                renderTimeline();
                renderOnionSkins();
                updateUndoRedoButtons();
                updateTimelineInfo();
            }
            function copyFrame(index) {
                const frameToCopy = frames[index];
                const newFrame = {
                    current: frameToCopy.current,
                    undoStack: [],
                    redoStack: []
                };
                frames.splice(index + 1, 0, newFrame);
                currentFrameIndex = index + 1;
                loadFrame(currentFrameIndex);
                renderTimeline();
                renderOnionSkins();
                updateUndoRedoButtons();
                updateTimelineInfo();
            }
            // --- Animation Playback ---
            function playAnimation() {
                if (isPlaying) return; isPlaying = true;
                playIcon.classList.add('hidden');
                document.getElementById('pause-icon').classList.remove('hidden');
                playPauseMobileBtn.innerHTML = pauseIcon.outerHTML;
                lastFrameTime = performance.now();
                animationLoop();
            }
            function pauseAnimation() {
                isPlaying = false;
                playIcon.classList.remove('hidden');
                document.getElementById('pause-icon').classList.add('hidden');
                 playPauseMobileBtn.innerHTML = playIcon.outerHTML;
                cancelAnimationFrame(animationFrameId);
            }
            function animationLoop(currentTime) {
                if (!isPlaying) return;
                animationFrameId = requestAnimationFrame(animationLoop);
                const fps = fpsSlider.value;
                const timeSinceLastFrame = currentTime - lastFrameTime;
                const frameInterval = 1000 / fps;
                if (timeSinceLastFrame > frameInterval) {
                    lastFrameTime = currentTime - (timeSinceLastFrame % frameInterval);
                    currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                    loadFrame(currentFrameIndex);
                    updateActiveFrame();
                }
            }
             // --- Animation Time & Frame Count Display ---
            function updateTimelineInfo() {
                const fps = fpsSlider.value;
                const duration = frames.length > 0 ? frames.length / fps : 0;
                animationTimeEl.textContent = `${duration.toFixed(1)}s`;
                frameCountEl.textContent = `${currentFrameIndex + 1} / ${frames.length}`;
            }

            // --- Export Logic ---
            async function exportAsWebM() {
                loadingText.textContent = 'Generating WebM...';
                loadingModal.classList.remove('hidden');

                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = animationCanvas.width;
                renderCanvas.height = animationCanvas.height;
                const renderCtx = renderCanvas.getContext('2d');
                const fps = parseInt(fpsSlider.value, 10);

                const stream = renderCanvas.captureStream(fps);
                const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

                const chunks = [];
                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const projectName = projectTitleEl.textContent.trim() || 'animation';
                    const safeFilename = projectName.replace(/[^a-z0-9_.-]/gi, '_').toLowerCase();
                    a.href = url;
                    a.download = `${safeFilename}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                    loadingModal.classList.add('hidden');
                };

                recorder.start();

                const bgDrawnImage = new Image();
                bgDrawnImage.src = backgroundData.current;
                await bgDrawnImage.decode();

                for (let i = 0; i < frames.length; i++) {
                    const frame = frames[i];
                    await new Promise(resolve => {
                        const frameImg = new Image();
                        frameImg.onload = () => {
                            renderCtx.clearRect(0, 0, renderCanvas.width, renderCanvas.height);
                            if (uploadedBackgroundImage) {
                                renderCtx.drawImage(uploadedBackgroundImage, 0, 0, renderCanvas.width, renderCanvas.height);
                            } else {
                                renderCtx.fillStyle = '#FFFFFF';
                                renderCtx.fillRect(0, 0, renderCanvas.width, renderCanvas.height);
                            }
                            renderCtx.drawImage(bgDrawnImage, 0, 0, renderCanvas.width, renderCanvas.height);
                            renderCtx.drawImage(frameImg, 0, 0, renderCanvas.width, renderCanvas.height);
                            // Wait for the next browser paint to ensure the canvas is updated before the next frame.
                            requestAnimationFrame(resolve);
                        };
                        frameImg.src = frame.current;
                    });
                }
                
                // A small delay to ensure the last frame is processed by the recorder before stopping.
                setTimeout(() => {
                    recorder.stop();
                }, 100);
            }

            // --- Background Image ---
             function drawUploadedBackground() {
                clearCanvas(imageBgCtx);
                if (uploadedBackgroundImage) { imageBgCtx.drawImage(uploadedBackgroundImage, 0, 0, imageBgCanvas.width, imageBgCanvas.height); }
             }
            function handleBackgroundUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => { uploadedBackgroundImage = img; drawUploadedBackground();};
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = null;
            }
            function clearBackground() {
                 uploadedBackgroundImage = null;
                 drawUploadedBackground();
                pushUndoState(); // for drawing bg
                const blankBg = document.createElement('canvas');
                blankBg.width = animationCanvas.width; blankBg.height = animationCanvas.height;
                backgroundData.current = blankBg.toDataURL();
                loadBackground();
             }
             // --- Onion Skinning ---
            function renderOnionSkins() {
                clearCanvas(onionBehindCtx);
                clearCanvas(onionAheadCtx);
                if (!onionSkinCheckbox.checked || activeLayer !== 'animation') return;
                const drawSkin = (ctx, frameIndex) => {
                    if (frameIndex < 0 || frameIndex >= frames.length) return;
                    const img = new Image();
                    img.onload = () => {
                        ctx.globalAlpha = 0.3;
                        ctx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height);
                        ctx.globalAlpha = 1.0;
                    };
                    img.src = frames[frameIndex].current;
                };
                drawSkin(onionBehindCtx, currentFrameIndex - 1);
                drawSkin(onionAheadCtx, currentFrameIndex + 1);
            }
            // --- Color Palette ---
            function renderColorPalette() {
                paletteColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-slate-600';
                    swatch.style.backgroundColor = color;
                    swatch.addEventListener('click', () => {
                        colorPicker.value = color;
                        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                        swatch.classList.add('active');
                    });
                    colorPalette.appendChild(swatch);
                });
            }

            // --- Zoom and Pan Logic ---
            function updateCanvasTransform() {
                canvasContainer.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})`;
                zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            }

            function handleZoom(e) {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const oldZoomLevel = zoomLevel;
                const rect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const mouseToCanvasX = (mouseX - panOffset.x) / oldZoomLevel;
                const mouseToCanvasY = (mouseY - panOffset.y) / oldZoomLevel;

                if (e.deltaY < 0) { // Zoom in
                    zoomLevel = Math.min(zoomLevel * (1 + zoomIntensity), 10);
                } else { // Zoom out
                    zoomLevel = Math.max(zoomLevel * (1 - zoomIntensity), 0.1);
                }

                panOffset.x = mouseX - mouseToCanvasX * zoomLevel;
                panOffset.y = mouseY - mouseToCanvasY * zoomLevel;

                updateCanvasTransform();
            }


            // --- Event Listeners ---
            projectTitleEl.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    projectTitleEl.blur(); // Unfocus the element
                }
            });
            projectTitleEl.addEventListener('blur', () => {
                if (projectTitleEl.textContent.trim() === '') {
                    projectTitleEl.textContent = 'Untitled Project';
                }
            });

            animationCanvas.addEventListener('dblclick', e => {
                if (activeTool === 'polygon') {
                    finishPolygon();
                }
            });
            viewport.addEventListener('mousedown', startDrawing);
            window.addEventListener('mousemove', draw);
            window.addEventListener('mouseup', stopDrawing);
            viewport.addEventListener('touchstart', startDrawing, { passive: false });
            window.addEventListener('touchmove', draw, { passive: false });
            window.addEventListener('touchend', stopDrawing);

            toolButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (activeTool === 'polygon' && button.dataset.tool !== 'polygon') {
                        if (polygonPoints.length > 0) {
                             const history = getActiveHistory();
                             if(history && history.undoStack.length > 0) {
                                 history.undoStack.pop();
                                 updateUndoRedoButtons();
                             }
                        }
                        polygonPoints = [];
                        clearCanvas(previewCtx);
                    }
                    activeTool = button.dataset.tool;
                    if(activeTool === 'pan') {
                        viewport.style.cursor = 'grab';
                    } else {
                        viewport.style.cursor = 'crosshair';
                    }
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
            });
            animationLayerBtn.addEventListener('click', () => {
                activeLayer = 'animation';
                animationLayerBtn.classList.add('active');
                backgroundLayerBtn.classList.remove('active');
                updateUndoRedoButtons();
                renderOnionSkins();
            });
            backgroundLayerBtn.addEventListener('click', () => {
                activeLayer = 'background';
                backgroundLayerBtn.classList.add('active');
                animationLayerBtn.classList.remove('active');
                updateUndoRedoButtons();
                renderOnionSkins();
            });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            window.addEventListener('keydown', (e) => {
                if (e.target.isContentEditable) return;
                 if (e.ctrlKey || e.metaKey) {
                    if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                    if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                }
                if (e.code === 'Space' && !isPanning) {
                    e.preventDefault();
                    previousTool = activeTool;
                    activeTool = 'pan';
                    viewport.style.cursor = 'grab';
                }
            });
             window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if(activeTool === 'pan'){
                        activeTool = previousTool;
                        if(activeTool !== 'pan'){
                           viewport.style.cursor = 'crosshair';
                        }
                    }
                }
            });
            brushSizeSlider.addEventListener('input', () => { brushSizeValue.textContent = brushSizeSlider.value; });
            addFrameBtn.addEventListener('click', addNewFrame);
            // Sync playback controls
            playPauseBtn.addEventListener('click', () => { isPlaying ? pauseAnimation() : playAnimation(); });
            playPauseMobileBtn.addEventListener('click', () => { isPlaying ? pauseAnimation() : playAnimation(); });
            fpsSlider.addEventListener('input', () => {
                 const val = fpsSlider.value;
                fpsValue.textContent = val;
                fpsSliderMobile.value = val;
                fpsValueMobile.textContent = val;
                updateTimelineInfo();
            });
             fpsSliderMobile.addEventListener('input', () => {
                 const val = fpsSliderMobile.value;
                fpsValueMobile.textContent = val;
                fpsSlider.value = val;
                fpsValue.textContent = val;
                updateTimelineInfo();
            });
            
            // Export Listeners
            exportWebmBtn.addEventListener('click', exportAsWebM);


            window.addEventListener('resize', fitCanvasToViewport);
            closeInstructionsModalBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            showInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            saveProjectBtn.addEventListener('click', saveProjectToFile);
            loadProjectInput.addEventListener('change', loadProjectFromFile);
            bgUploadInput.addEventListener('change', handleBackgroundUpload);
            clearBgBtn.addEventListener('click', clearBackground);
            onionSkinCheckbox.addEventListener('change', renderOnionSkins);
            colorPicker.addEventListener('input', () => {
                 document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            });

            // Zoom Listeners
            viewport.addEventListener('wheel', handleZoom);
            zoomInBtn.addEventListener('click', () => {
                const rect = viewport.getBoundingClientRect();
                handleZoom({ preventDefault: () => {}, clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2, deltaY: -1 });
            });
            zoomOutBtn.addEventListener('click', () => {
                 const rect = viewport.getBoundingClientRect();
                handleZoom({ preventDefault: () => {}, clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2, deltaY: 1 });
            });
            resetZoomBtn.addEventListener('click', fitCanvasToViewport);

            // --- Initialization ---
            function initialize() {
                playPauseMobileBtn.innerHTML = playIcon.outerHTML; // Set initial mobile icon
                renderColorPalette();
                initializeNewProject();

                if (!localStorage.getItem('animationToolInstructionsSeen')) {
                    instructionsModal.classList.remove('hidden');
                    localStorage.setItem('animationToolInstructionsSeen', 'true');
                }
            }
            function initializeNewProject() {
                projectTitleEl.textContent = 'MovingLines';
                const blankCanvas = document.createElement('canvas');
                blankCanvas.width = 1280; blankCanvas.height = 720;
                frames = [{
                    current: blankCanvas.toDataURL(),
                    undoStack: [],
                    redoStack: []
                }];
                backgroundData.current = blankCanvas.toDataURL();
                initialCanvasSetup();
                renderTimeline();
                loadFrame(0);
                loadBackground();
                updateTimelineThumbnail(0);
                updateUndoRedoButtons();
                updateTimelineInfo();
            }
            initialize();
        });
    </script>
</body>
</html>

