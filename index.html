<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Animation Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .timeline-frame {
            border: 2px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .timeline-frame.active {
            border-color: #4f46e5; /* indigo-600 */
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.7);
        }
        .tool-button.active, .layer-button.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border-color: #6366f1; /* indigo-500 */
        }
        .loader {
            border: 4px solid #4b5563; /* gray-600 */
            border-radius: 50%;
            border-top: 4px solid #4f46e5; /* indigo-600 */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            height: 8px;
        }
        .timeline-container::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        .timeline-container::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* Canvas Layering */
        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            max-width: 100%;
            overflow: hidden; /* Important for zoom/pan */
        }
        .base-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            touch-action: none;
        }
        #onion-skin-canvas-behind,
        #onion-skin-canvas-ahead,
        #preview-canvas { /* preview canvas for shapes */
            pointer-events: none;
        }
        #image-bg-canvas {
             background-color: white;
        }

        /* Disabled button style */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .color-swatch {
            transition: transform 0.1s ease-in-out;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.active {
            box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5;
        }

    </style>
</head>
<body class="bg-slate-900 text-gray-300 flex flex-col h-screen overflow-hidden">
    
    <!-- Autosave Notification -->
    <div id="autosave-notification" class="hidden fixed top-0 left-0 right-0 bg-indigo-600 text-white p-3 text-center z-50 flex justify-center items-center gap-4 shadow-lg">
        <p>Unsaved work from a previous session found. Would you like to restore it?</p>
        <button id="restore-autosave" class="bg-green-500 hover:bg-green-400 px-4 py-1 rounded-md text-sm font-semibold">Restore</button>
        <button id="dismiss-autosave" class="bg-red-500 hover:bg-red-400 px-4 py-1 rounded-md text-sm font-semibold">Dismiss</button>
    </div>


    <!-- Header -->
    <header class="bg-slate-800 shadow-md p-3 flex justify-between items-center z-20 border-b border-slate-700 flex-shrink-0">
        <h1 class="text-lg md:text-xl font-bold text-white whitespace-nowrap">Web Animation Tool</h1>
        
        <!-- Playback Controls -->
        <div class="hidden md:flex items-center gap-4 absolute left-1/2 -translate-x-1/2">
             <button id="play-pause" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-pause-fill hidden" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>
            </button>
            <div class="flex items-center gap-2">
                <label for="fps-slider" class="text-sm font-medium">FPS:</label>
                <input type="range" id="fps-slider" min="1" max="30" value="12" class="w-24 h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                <span id="fps-value" class="text-sm font-semibold w-6 text-center">12</span>
            </div>
        </div>

        <div class="flex items-center gap-2 md:gap-4">
            <button id="show-instructions" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 md:px-4 rounded-lg text-sm">Help</button>
            <button id="save-project" class="bg-green-600 hover:bg-green-500 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16"><path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v4.5h2a.5.5 0 0 1 .354.854l-2.5 2.5a.5.5 0 0 1-.708 0l-2.5-2.5A.5.5 0 0 1 5.5 6.5h2V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/></svg>
                <span class="hidden md:inline">Save</span>
            </button>
            <label for="load-project-input" class="bg-yellow-500 hover:bg-yellow-400 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2 cursor-pointer">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder2-open" viewBox="0 0 16 16"><path d="M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.958 0 1.76.746 1.97.684l.248-.06c.26-.06.58.11.732.358L8.5 3.5h5.5A1.5 1.5 0 0 1 15.5 5v.54L14.05 8.4a.5.5 0 0 1-.45.3H5.4a.5.5 0 0 1-.45-.3L3.5 5.54V5.5A1.5 1.5 0 0 1 2 4H1.5V3.5zM2 6h12v5a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6z"/><path d="M.5 4a.5.5 0 0 0 0 1h15a.5.5 0 0 0 0-1H.5z"/></svg>
                <span class="hidden md:inline">Load</span>
            </label>
            <input type="file" id="load-project-input" class="hidden" accept=".anim">
             <button id="export-gif" class="bg-purple-600 hover:bg-purple-500 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                <span class="hidden md:inline">Export</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-col md:flex-row flex-grow overflow-hidden">
        <!-- Toolbar -->
        <aside class="w-full md:w-56 bg-slate-800 p-3 flex-shrink-0 flex flex-col gap-3 overflow-y-auto z-10 border-b md:border-b-0 md:border-r border-slate-700">
            <!-- Layers -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Layer</h3>
                 <div class="flex flex-col gap-2">
                    <button id="animation-layer-btn" class="layer-button active bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Animation</button>
                    <button id="background-layer-btn" class="layer-button bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Background</button>
                </div>
            </div>
            
            <!-- Tools -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Tool</h3>
                <div id="tools-container" class="grid grid-cols-4 gap-2">
                    <button data-tool="pencil" class="tool-button active p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Pencil">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>
                    </button>
                    <button data-tool="eraser" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Eraser">
                         <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm.66 11.34L3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/></svg>
                    </button>
                    <button data-tool="lasso" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Lasso Erase">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5">
                            <path d="M4.23223 15.7678C1.20573 12.7413 1.20573 7.75868 4.23223 4.73223C7.25873 1.70573 12.2413 1.70573 15.2678 4.73223C18.2943 7.75868 18.2943 12.7413 15.2678 15.7678L12.5 18.5L9.5 21.5L4.23223 15.7678Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"/>
                        </svg>
                    </button>
                     <button data-tool="line" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Line">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.5 19.5L19.5 4.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="rectangle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Rectangle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="circle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Circle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button id="undo-btn" class="p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
                        </svg>
                    </button>
                    <button id="redo-btn" class="p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                    </button>
                </div>
            </div>
             
            <!-- Brush Size -->
            <div>
                <label for="brush-size" class="text-xs font-semibold text-gray-400 uppercase">Brush Size</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="brush-size-value" class="text-sm font-semibold w-6 text-center">5</span>
                </div>
            </div>
            <!-- Color -->
            <div>
                <label for="color-picker" class="text-xs font-semibold mb-1 text-gray-400 uppercase">Color</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="color" id="color-picker" value="#000000" class="w-10 h-10 rounded-lg cursor-pointer border-2 border-slate-600">
                    <div id="color-palette" class="grid grid-cols-5 gap-1 flex-1">
                        <!-- Color swatches will be inserted here -->
                    </div>
                </div>
            </div>
            <!-- Onion Skin -->
            <div>
                <label for="onion-skin" class="flex items-center cursor-pointer select-none">
                    <input type="checkbox" id="onion-skin" class="h-4 w-4 rounded border-gray-500 text-indigo-500 focus:ring-indigo-600 bg-slate-700">
                    <span class="ml-2 text-sm font-medium">Onion Skin</span>
                </label>
            </div>
            <!-- Background Options -->
            <div>
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Background Options</h3>
                <div class="flex flex-col gap-2">
                    <button id="generate-bg-btn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg text-sm">✨ Generate BG with AI</button>
                    <label for="bg-upload-input" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-sm text-center cursor-pointer">Upload Image</label>
                    <input type="file" id="bg-upload-input" class="hidden" accept="image/*">
                    <button id="clear-bg-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg text-sm">Clear Background</button>
                </div>
            </div>
             <!-- Playback for Mobile -->
             <div class="md:hidden">
                <h3 class="text-xs font-semibold mb-1 text-gray-400 uppercase">Playback</h3>
                <div class="flex items-center justify-center gap-4 mt-2">
                    <button id="play-pause-mobile" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                         <!-- Icons will be cloned here by JS -->
                    </button>
                </div>
                 <div class="flex items-center gap-2 mt-2">
                    <label for="fps-slider-mobile" class="text-sm font-medium">FPS:</label>
                    <input type="range" id="fps-slider-mobile" min="1" max="30" value="12" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="fps-value-mobile" class="text-sm font-semibold w-6 text-center">12</span>
                </div>
            </div>
        </aside>

        <!-- Canvas -->
        <main class="flex-grow flex items-center justify-center p-2 md:p-4 bg-slate-900 overflow-hidden relative">
             <div id="canvas-viewport" class="w-full h-full flex items-center justify-center">
                <div class="canvas-container shadow-xl">
                    <canvas id="image-bg-canvas" class="base-canvas"></canvas>
                    <canvas id="drawing-bg-canvas" class="base-canvas"></canvas>
                    <canvas id="onion-skin-canvas-behind" class="base-canvas"></canvas>
                    <canvas id="animation-canvas" class="base-canvas cursor-crosshair"></canvas>
                    <canvas id="onion-skin-canvas-ahead" class="base-canvas"></canvas>
                    <canvas id="preview-canvas" class="base-canvas"></canvas>
                </div>
            </div>
            <!-- Zoom Controls -->
            <div class="absolute bottom-4 right-4 md:right-8 bg-slate-700 rounded-lg shadow-lg p-1 flex items-center gap-1 text-white">
                <button id="zoom-out-btn" class="w-8 h-8 flex items-center justify-center hover:bg-slate-600 rounded-md">-</button>
                <span id="zoom-level-display" class="text-xs font-mono w-12 text-center">100%</span>
                <button id="zoom-in-btn" class="w-8 h-8 flex items-center justify-center hover:bg-slate-600 rounded-md">+</button>
                <button id="zoom-reset-btn" class="w-8 h-8 flex items-center justify-center hover:bg-slate-600 rounded-md">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-aspect-ratio" viewBox="0 0 16 16"><path d="M11.25 2.5v9h-9v-9h9zM12 2H3a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z"/><path d="M1.5 12.5v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1a.5.5 0 0 0-1 0v.5a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-.5a.5.5 0 0 0-1 0z"/></svg>
                </button>
            </div>
        </main>
    </div>

    <!-- Timeline -->
    <footer class="bg-slate-800 shadow-inner p-3 z-20 border-t border-slate-700 flex-shrink-0">
        <div class="flex justify-between items-center mb-2">
            <h3 class="text-sm font-semibold text-gray-400 uppercase">Timeline</h3>
            <div class="flex items-center gap-4">
                <span id="frame-count" class="text-sm text-gray-400 font-mono">1 / 1</span>
                <span id="animation-time" class="text-sm text-gray-400 font-mono">0.0s</span>
            </div>
        </div>
        <div class="w-full overflow-y-auto pb-2 timeline-container max-h-60">
            <div id="timeline" class="flex flex-wrap items-start gap-2 p-2 bg-slate-700 rounded-lg min-h-28">
                 <button id="add-frame" class="flex-shrink-0 bg-slate-600 hover:bg-slate-500 text-gray-300 font-bold h-24 w-24 rounded-full flex items-center justify-center p-2" title="Add New Frame">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/></svg>
                 </button>
            </div>
        </div>
    </footer>
    
    <!-- GIF Export library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <!-- Gemini AI Background Generation Modal -->
    <div id="gemini-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-slate-800 rounded-lg p-6 max-w-lg w-full border border-slate-700 flex flex-col gap-4">
            <div class="flex justify-between items-center">
                <h2 class="text-xl font-bold text-white">✨ Generate Background with AI</h2>
                <button id="close-gemini-modal" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div>
                <label for="gemini-prompt" class="block text-sm font-medium text-gray-300 mb-2">Describe the background you want to create:</label>
                <textarea id="gemini-prompt" rows="3" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2 text-white focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., A magical, glowing forest at twilight, cartoon style"></textarea>
            </div>
            <div id="gemini-result-container" class="relative w-full aspect-video bg-slate-900 rounded-lg hidden items-center justify-center">
                <img id="gemini-image-result" src="" class="w-full h-full object-contain rounded-lg">
                <div id="gemini-loading" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-lg">
                    <div class="loader"></div>
                </div>
            </div>
            <div id="gemini-error-message" class="hidden text-red-400 text-sm text-center"></div>
            <div class="flex justify-end items-center gap-3">
                 <button id="generate-gemini-btn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-5 rounded-lg disabled:bg-slate-600">Generate</button>
                 <button id="use-gemini-image-btn" class="hidden bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-5 rounded-lg">Use Image</button>
            </div>
        </div>
    </div>


    <!-- Modal for loading spinner -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
        <div class="bg-slate-800 p-8 rounded-lg shadow-xl text-center border border-slate-700">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-lg font-medium text-white">Generating GIF...</p>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 text-white p-8 rounded-lg shadow-xl max-w-2xl w-full border border-slate-700">
            <h2 class="text-2xl font-bold mb-6 text-center">How to Use the Animation Tool</h2>
            <ol class="list-decimal list-inside space-y-3 text-gray-300">
                <li><b>✨ AI Backgrounds:</b> Click 'Generate BG with AI' to describe and create a background using generative AI.</li>
                <li><b>Layers:</b> Switch between drawing on the 'Animation' layer (for moving parts) and the 'Background' layer (for static scenery).</li>
                <li><b>Tools:</b> Select a tool like Pencil, Eraser, Lasso, or Shapes from the sidebar.</li>
                <li><b>Undo/Redo:</b> Use the undo/redo buttons in the sidebar or press <code>Ctrl+Z</code> / <code>Ctrl+Y</code>.</li>
                <li><b>Save/Load Project:</b> Use the 'Save' and 'Load' buttons to save your progress as a <code>.anim</code> file and open it again later.</li>
                <li><b>Add & Duplicate Frames:</b> Use the <span class="text-green-400">'+'</span> button in the timeline to add a new frame. Hover over a frame to find the copy icon to duplicate it.</li>
                <li><b>Onion Skin:</b> Check this box in the toolbar to see faint outlines of your previous and *next* drawings.</li>
                <li><b>Play & Adjust FPS:</b> Use the play button and <span class="text-yellow-400">FPS</span> slider in the toolbar to preview your animation.</li>
                <li><b>Export GIF:</b> When you're finished, use the 'Export GIF' button to save your animation as a downloadable .gif file.</li>
            </ol>
            <div class="mt-8 text-center">
                <button id="close-instructions-modal" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-8 rounded-lg">Got it!</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ... (previous variable declarations) ...
            const generateBgBtn = document.getElementById('generate-bg-btn');
            const geminiModal = document.getElementById('gemini-modal');
            const closeGeminiModalBtn = document.getElementById('close-gemini-modal');
            const geminiPromptInput = document.getElementById('gemini-prompt');
            const generateGeminiBtn = document.getElementById('generate-gemini-btn');
            const useGeminiImageBtn = document.getElementById('use-gemini-image-btn');
            const geminiResultContainer = document.getElementById('gemini-result-container');
            const geminiImageResult = document.getElementById('gemini-image-result');
            const geminiLoading = document.getElementById('gemini-loading');
            const geminiErrorMessage = document.getElementById('gemini-error-message');


            const canvasViewport = document.getElementById('canvas-viewport');
            const imageBgCanvas = document.getElementById('image-bg-canvas');
            const drawingBgCanvas = document.getElementById('drawing-bg-canvas');
            const onionBehindCanvas = document.getElementById('onion-skin-canvas-behind');
            const animationCanvas = document.getElementById('animation-canvas');
            const onionAheadCanvas = document.getElementById('onion-skin-canvas-ahead');
            const previewCanvas = document.getElementById('preview-canvas');

            const allCanvases = [imageBgCanvas, drawingBgCanvas, onionBehindCanvas, animationCanvas, onionAheadCanvas, previewCanvas];

            const animCtx = animationCanvas.getContext('2d', { willReadFrequently: true });
            const imageBgCtx = imageBgCanvas.getContext('2d');
            const drawingBgCtx = drawingBgCanvas.getContext('2d');
            const onionBehindCtx = onionBehindCanvas.getContext('2d');
            const onionAheadCtx = onionAheadCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');

            // --- DOM Elements ---
            const animationLayerBtn = document.getElementById('animation-layer-btn');
            const backgroundLayerBtn = document.getElementById('background-layer-btn');
            const toolsContainer = document.getElementById('tools-container');
            const toolButtons = document.querySelectorAll('.tool-button');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const colorPicker = document.getElementById('color-picker');
            const colorPalette = document.getElementById('color-palette');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const onionSkinCheckbox = document.getElementById('onion-skin');
            const addFrameBtn = document.getElementById('add-frame');
            const timeline = document.getElementById('timeline');
            const animationTimeEl = document.getElementById('animation-time');
            const frameCountEl = document.getElementById('frame-count');
            // Desktop Playback
            const playPauseBtn = document.getElementById('play-pause');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const fpsSlider = document.getElementById('fps-slider');
            const fpsValue = document.getElementById('fps-value');
            // Mobile Playback
            const playPauseMobileBtn = document.getElementById('play-pause-mobile');
            const fpsSliderMobile = document.getElementById('fps-slider-mobile');
            const fpsValueMobile = document.getElementById('fps-value-mobile');

            const exportGifBtn = document.getElementById('export-gif');
            const loadingModal = document.getElementById('loading-modal');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsModalBtn = document.getElementById('close-instructions-modal');
            const showInstructionsBtn = document.getElementById('show-instructions');
            const saveProjectBtn = document.getElementById('save-project');
            const loadProjectInput = document.getElementById('load-project-input');
            const bgUploadInput = document.getElementById('bg-upload-input');
            const clearBgBtn = document.getElementById('clear-bg-btn');
            const autosaveNotification = document.getElementById('autosave-notification');
            const restoreAutosaveBtn = document.getElementById('restore-autosave');
            const dismissAutosaveBtn = document.getElementById('dismiss-autosave');
            
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomResetBtn = document.getElementById('zoom-reset-btn');
            const zoomLevelDisplay = document.getElementById('zoom-level-display');


            // --- State ---
            let frames = [];
            let backgroundData = {
                current: null,
                undoStack: [],
                redoStack: []
            };
            let currentFrameIndex = 0;
            let isDrawing = false;
            let activeTool = 'pencil';
            let activeLayer = 'animation'; // 'animation' or 'background'
            let shapeStartPos = null;
            let isPlaying = false;
            let animationFrameId;
            let lastFrameTime = 0;
            let uploadedBackgroundImage = null;
            let lassoPoints = [];
            let autosaveTimeout;
            let isPanning = false;
            let lastPanPosition = { x: 0, y: 0 };
            
            let transform = {
                scale: 1,
                panX: 0,
                panY: 0
            };

            
            const paletteColors = [
                '#ffffff', '#c2c2c2', '#898989', '#505050', '#000000',
                '#ff5b5b', '#ff985b', '#ffff5b', '#98ff5b', '#5bff98',
                '#5bffff', '#5b98ff', '#985bff', '#ff5b98', '#ff5bff'
            ];

            // --- Gemini API Logic ---

            async function generateImageWithGemini(prompt) {
                geminiResultContainer.classList.remove('hidden');
                geminiLoading.classList.remove('hidden');
                geminiImageResult.src = '';
                generateGeminiBtn.disabled = true;
                geminiErrorMessage.classList.add('hidden');
                
                const apiKey = "AIzaSyBBJW37Grl058s_Y6YM5R7Hpafqfq4qHOM"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                const payload = {
                    instances: [{ prompt: prompt }],
                    parameters: { "sampleCount": 1 }
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`API Error: ${errorBody.error?.message || 'Unknown error'}`);
                    }

                    const result = await response.json();
                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        geminiImageResult.src = imageUrl;
                        useGeminiImageBtn.classList.remove('hidden');
                    } else {
                        throw new Error('No image data received from API.');
                    }
                } catch (error) {
                    console.error('Gemini API Error:', error);
                    geminiErrorMessage.textContent = `Error: ${error.message}`;
                    geminiErrorMessage.classList.remove('hidden');
                } finally {
                    geminiLoading.classList.add('hidden');
                    generateGeminiBtn.disabled = false;
                }
            }
            
            // --- Autosave ---
            function triggerAutosave() {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = setTimeout(autosaveProject, 2000);
            }

            function autosaveProject() {
                 const projectData = {
                    frames: frames.map(f => f.current),
                    drawnBackground: backgroundData.current,
                    uploadedImage: uploadedBackgroundImage ? uploadedBackgroundImage.src : null,
                };
                localStorage.setItem('autosavedAnimationProject', JSON.stringify(projectData));
            }

            function loadProjectData(projectData) {
                if (!projectData.frames) throw new Error('Invalid project file');
                
                frames = projectData.frames.map(frameDataURL => ({
                    current: frameDataURL, undoStack: [], redoStack: [],
                }));

                backgroundData = {
                    current: projectData.drawnBackground || drawingBgCanvas.toDataURL(),
                    undoStack: [], redoStack: []
                };

                currentFrameIndex = 0;

                const loadVisuals = () => {
                    renderTimeline();
                    redrawAll();
                    updateUndoRedoButtons();
                    updateTimelineInfo();
                };
                
                if (projectData.uploadedImage) {
                    const img = new Image();
                    img.onload = () => { uploadedBackgroundImage = img; loadVisuals(); };
                    img.src = projectData.uploadedImage;
                } else {
                    uploadedBackgroundImage = null; loadVisuals();
                }
            }


            // --- Canvas Setup ---
            function resizeAndRedraw() {
                const { width, height } = canvasViewport.getBoundingClientRect();
                 allCanvases.forEach(c => {
                    c.width = width;
                    c.height = height;
                });
                
                if (!backgroundData.current) {
                    // Create a high-res backing canvas
                    const backingCanvas = document.createElement('canvas');
                    backingCanvas.width = 1920;
                    backingCanvas.height = 1080;
                    backgroundData.current = backingCanvas.toDataURL();
                }

                redrawAll();
            }

            function redrawAll() {
                const contexts = [imageBgCtx, drawingBgCtx, animCtx, onionBehindCtx, onionAheadCtx, previewCtx];
                contexts.forEach(ctx => {
                    ctx.save();
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.translate(transform.panX, transform.panY);
                    ctx.scale(transform.scale, transform.scale);
                });

                if (uploadedBackgroundImage) imageBgCtx.drawImage(uploadedBackgroundImage, 0, 0);

                const bgImg = new Image();
                bgImg.src = backgroundData.current;
                drawingBgCtx.drawImage(bgImg, 0, 0);

                const frameImg = new Image();
                if (frames[currentFrameIndex]) {
                    frameImg.src = frames[currentFrameIndex].current;
                    animCtx.drawImage(frameImg, 0, 0);
                }
                
                renderOnionSkins(true);

                contexts.forEach(ctx => ctx.restore());
            }
            
            // --- History (Undo/Redo) ---
            function getActiveHistory() {
                return activeLayer === 'animation' ? frames[currentFrameIndex] : backgroundData;
            }

            function pushUndoState() {
                const history = getActiveHistory();
                if (!history) return;
                history.undoStack.push(history.current);
                history.redoStack = []; // Clear redo stack on new action
                if (history.undoStack.length > 30) { 
                    history.undoStack.shift();
                }
                updateUndoRedoButtons();
                triggerAutosave();
            }
            
            function undo() {
                const history = getActiveHistory();
                if (!history || history.undoStack.length === 0) return;
                history.redoStack.push(history.current);
                history.current = history.undoStack.pop();
                
                if (activeLayer === 'animation') {
                    updateTimelineThumbnail(currentFrameIndex);
                }
                redrawAll();
                updateUndoRedoButtons();
                triggerAutosave();
            }

            function redo() {
                const history = getActiveHistory();
                if (!history || history.redoStack.length === 0) return;
                history.undoStack.push(history.current);
                history.current = history.redoStack.pop();

                if (activeLayer === 'animation') {
                   updateTimelineThumbnail(currentFrameIndex);
                }
                redrawAll();
                updateUndoRedoButtons();
                triggerAutosave();
            }

            function updateUndoRedoButtons() {
                const history = getActiveHistory();
                if (!history) {
                    undoBtn.disabled = true;
                    redoBtn.disabled = true;
                    return;
                };
                undoBtn.disabled = history.undoStack.length === 0;
                redoBtn.disabled = history.redoStack.length === 0;
            }


            // --- Drawing Logic ---
            function getTransformedMousePos(e) {
                const rect = animationCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const screenX = clientX - rect.left;
                const screenY = clientY - rect.top;

                return {
                    x: (screenX - transform.panX) / transform.scale,
                    y: (screenY - transform.panY) / transform.scale,
                };
            }

            function getDrawingContext() {
                const backingCanvas = document.createElement('canvas');
                const backingCtx = backingCanvas.getContext('2d');
                
                const sourceData = activeLayer === 'animation' ? frames[currentFrameIndex].current : backgroundData.current;
                const img = new Image();
                img.src = sourceData;
                backingCanvas.width = img.width;
                backingCanvas.height = img.height;
                backingCtx.drawImage(img, 0, 0);
                return backingCtx;
            }
            
            function commitDrawing(backingCtx) {
                const dataUrl = backingCtx.canvas.toDataURL();
                if (activeLayer === 'animation') {
                    frames[currentFrameIndex].current = dataUrl;
                    updateTimelineThumbnail(currentFrameIndex);
                } else {
                    backgroundData.current = dataUrl;
                }
                redrawAll();
            }


            function startDrawing(e) {
                if (isPanning) return;
                if (e.touches) e.preventDefault();
                isDrawing = true;
                const pos = getTransformedMousePos(e);

                if (['pencil', 'eraser'].includes(activeTool)) {
                    pushUndoState();
                    const backingCtx = getDrawingContext();
                    backingCtx.beginPath();
                    backingCtx.moveTo(pos.x, pos.y);
                    draw(e, backingCtx);
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    shapeStartPos = pos;
                } else if (activeTool === 'lasso') {
                    lassoPoints = [pos];
                    clearCanvas(previewCtx);
                }
            }
            
            function draw(e, backingCtx) {
                if (!isDrawing || isPanning) return;
                if (e.touches) e.preventDefault();
                const pos = getTransformedMousePos(e);
                
                if (['pencil', 'eraser'].includes(activeTool)) {
                    backingCtx.lineWidth = brushSizeSlider.value;
                    backingCtx.lineCap = 'round';
                    backingCtx.lineJoin = 'round';
                    backingCtx.globalCompositeOperation = activeTool === 'eraser' ? 'destination-out' : 'source-over';
                    backingCtx.strokeStyle = colorPicker.value;
                    backingCtx.lineTo(pos.x, pos.y);
                    backingCtx.stroke();
                    backingCtx.beginPath();
                    backingCtx.moveTo(pos.x, pos.y);
                    commitDrawing(backingCtx); // Inefficient but simple for now
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    drawShapePreview(pos);
                } else if (activeTool === 'lasso') {
                    lassoPoints.push(pos);
                    drawLassoPath();
                }
            }

            function stopDrawing(e) {
                if (!isDrawing || isPanning) return;
                isDrawing = false;
                
                if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    pushUndoState();
                    const backingCtx = getDrawingContext();
                    drawShape(getTransformedMousePos(e), backingCtx);
                    commitDrawing(backingCtx);
                    shapeStartPos = null;
                } else if (activeTool === 'lasso') {
                    if (lassoPoints.length > 2) {
                        pushUndoState();
                        const backingCtx = getDrawingContext();
                        applyLassoDelete(backingCtx);
                        commitDrawing(backingCtx);
                    }
                    lassoPoints = [];
                    clearCanvas(previewCtx);
                }
                
                triggerAutosave();
            }
            
            // --- Shape Drawing Logic ---
            function drawShapePreview(currentPos) {
                clearCanvas(previewCtx);
                previewCtx.save();
                previewCtx.translate(transform.panX, transform.panY);
                previewCtx.scale(transform.scale, transform.scale);
                previewCtx.lineWidth = brushSizeSlider.value;
                previewCtx.strokeStyle = colorPicker.value;
                previewCtx.beginPath();
                
                const start = shapeStartPos;
                const end = currentPos;
                
                if (activeTool === 'line') {
                    previewCtx.moveTo(start.x, start.y);
                    previewCtx.lineTo(end.x, end.y);
                } else if (activeTool === 'rectangle') {
                    previewCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (activeTool === 'circle') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    previewCtx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                }
                previewCtx.stroke();
                previewCtx.restore();
            }

            function drawShape(endPos, ctx) {
                clearCanvas(previewCtx);
                ctx.lineWidth = brushSizeSlider.value;
                ctx.strokeStyle = colorPicker.value;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();

                const start = shapeStartPos;
                const end = endPos;

                if (activeTool === 'line') {
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                } else if (activeTool === 'rectangle') {
                    ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (activeTool === 'circle') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    ctx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                }
                ctx.stroke();
            }


             // --- Lasso Logic ---
            function drawLassoPath() {
                 if (lassoPoints.length < 2) return;
                clearCanvas(previewCtx);
                previewCtx.save();
                previewCtx.translate(transform.panX, transform.panY);
                previewCtx.scale(transform.scale, transform.scale);
                previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                previewCtx.lineWidth = 2 / transform.scale;
                previewCtx.setLineDash([6 / transform.scale, 6 / transform.scale]);
                previewCtx.beginPath();
                previewCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    previewCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                previewCtx.stroke();
                previewCtx.restore();
            }

            function applyLassoDelete(ctx) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                ctx.closePath();
                ctx.clip();
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.restore();
            }

            // --- Project Save/Load ---
            function saveProjectToFile() {
                const projectData = {
                    frames: frames.map(f => f.current),
                    drawnBackground: backgroundData.current,
                    uploadedImage: uploadedBackgroundImage ? uploadedBackgroundImage.src : null,
                };
                const jsonString = JSON.stringify(projectData);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation-project.anim';
                a.click();
                URL.revokeObjectURL(url);
            }

            function loadProjectFromFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        loadProjectData(projectData);
                    } catch (error) {
                        console.error("Error loading project:", error);
                        alert('Could not load project file.');
                    }
                };
                reader.readAsText(file);
                e.target.value = null;
            }

            // --- Frame Management ---
            function saveFrame() {
                // This is handled by commitDrawing
            }

            function loadFrame(index) {
                // This is handled by redrawAll
            }
            
            function saveBackground() {
                // This is handled by commitDrawing
            }
            
            function loadBackground() {
                // This is handled by redrawAll
            }


            function clearCanvas(context) {
                context.save();
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
                context.restore();
            }

            // --- Timeline UI ---
            function renderTimeline() {
                const frameElements = timeline.querySelectorAll('.relative.flex-shrink-0.group');
                frameElements.forEach(el => el.remove());
                
                frames.forEach((_, index) => {
                    const frameContainer = createFrameElement(index);
                    timeline.insertBefore(frameContainer, addFrameBtn);
                });
                frames.forEach((_, index) => { updateTimelineThumbnail(index); });
                updateActiveFrame();
            }
            
            function createFrameElement(index) {
                const frameContainer = document.createElement('div');
                frameContainer.className = 'relative flex-shrink-0 group';
                const frameElement = document.createElement('canvas');
                frameElement.className = 'timeline-frame h-24 w-40 bg-white rounded-lg cursor-pointer border-2 border-slate-600';
                frameElement.dataset.index = index;
                frameContainer.appendChild(frameElement);
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.className = 'absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full h-6 w-6 flex items-center justify-center font-bold opacity-0 group-hover:opacity-100 transition-opacity';
                deleteBtn.title = 'Delete Frame';
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteFrame(index); };
                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-files" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg>';
                copyBtn.className = 'absolute top-0 left-0 -mt-2 -ml-2 bg-blue-500 text-white rounded-full h-6 w-6 flex items-center justify-center font-bold opacity-0 group-hover:opacity-100 transition-opacity';
                copyBtn.title = 'Duplicate Frame';
                copyBtn.onclick = (e) => { e.stopPropagation(); copyFrame(index); };
                frameContainer.appendChild(deleteBtn);
                frameContainer.appendChild(copyBtn);
                frameElement.addEventListener('click', () => {
                    if (isPlaying) return;
                    currentFrameIndex = index;
                    redrawAll();
                    updateActiveFrame();
                    updateUndoRedoButtons();
                });
                return frameContainer;
            }

            function updateTimelineThumbnail(index) {
                const thumbCanvas = timeline.querySelector(`canvas[data-index='${index}']`);
                if (!thumbCanvas || !frames[index] || !frames[index].current) return;
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCanvas.width = 160;
                thumbCanvas.height = 90;
                const img = new Image();
                img.onload = () => {
                    thumbCtx.fillStyle = 'white';
                    thumbCtx.fillRect(0,0,thumbCanvas.width, thumbCanvas.height);
                    thumbCtx.drawImage(img, 0, 0, thumbCanvas.width, thumbCanvas.height);
                };
                img.src = frames[index].current;
            }

            function updateActiveFrame() {
                timeline.querySelectorAll('.timeline-frame').forEach((el, i) => {
                    el.classList.toggle('active', i === currentFrameIndex);
                });
                updateTimelineInfo();
            }
            
            function addNewFrame() {
                const backingCanvas = document.createElement('canvas');
                let img = new Image();
                img.src = frames[0].current;
                backingCanvas.width = img.width;
                backingCanvas.height = img.height;

                const newFrame = {
                    current: backingCanvas.toDataURL(),
                    undoStack: [],
                    redoStack: []
                };
                frames.splice(currentFrameIndex + 1, 0, newFrame);
                currentFrameIndex++;
                redrawAll();
                renderTimeline();
                updateUndoRedoButtons();
                updateTimelineInfo();
                triggerAutosave();
            }
            
            function deleteFrame(index) {
                if (frames.length <= 1) return;
                frames.splice(index, 1);
                currentFrameIndex = Math.max(0, currentFrameIndex >= index ? currentFrameIndex - 1 : currentFrameIndex);
                redrawAll();
                renderTimeline();
                updateUndoRedoButtons();
                updateTimelineInfo();
                triggerAutosave();
            }

            function copyFrame(index) {
                const frameToCopy = frames[index];
                const newFrame = {
                    current: frameToCopy.current,
                    undoStack: [],
                    redoStack: []
                };
                frames.splice(index + 1, 0, newFrame);
                currentFrameIndex = index + 1;
                redrawAll();
                renderTimeline();
                updateUndoRedoButtons();
                updateTimelineInfo();
                triggerAutosave();
            }

            // --- Animation Playback ---
            function playAnimation() {
                if (isPlaying) return; isPlaying = true;
                playIcon.classList.add('hidden');
                document.getElementById('pause-icon').classList.remove('hidden');
                playPauseMobileBtn.innerHTML = pauseIcon.outerHTML;

                lastFrameTime = performance.now();
                animationLoop();
            }

            function pauseAnimation() {
                isPlaying = false;
                playIcon.classList.remove('hidden');
                document.getElementById('pause-icon').classList.add('hidden');
                 playPauseMobileBtn.innerHTML = playIcon.outerHTML;
                cancelAnimationFrame(animationFrameId);
            }
            
            function animationLoop(currentTime) {
                if (!isPlaying) return;
                animationFrameId = requestAnimationFrame(animationLoop);
                const fps = fpsSlider.value;
                const timeSinceLastFrame = currentTime - lastFrameTime;
                const frameInterval = 1000 / fps;
                if (timeSinceLastFrame > frameInterval) {
                    lastFrameTime = currentTime - (timeSinceLastFrame % frameInterval);
                    currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                    redrawAll();
                    updateActiveFrame();
                }
            }

             // --- Animation Time & Frame Count Display ---
            function updateTimelineInfo() {
                const fps = fpsSlider.value;
                const duration = frames.length > 0 ? frames.length / fps : 0;
                animationTimeEl.textContent = `${duration.toFixed(1)}s`;
                frameCountEl.textContent = `${currentFrameIndex + 1} / ${frames.length}`;
            }

            // --- GIF Export ---
            async function exportToGif() {
                loadingModal.classList.remove('hidden');
                 const backingCanvas = document.createElement('canvas');
                let tempImg = new Image();
                tempImg.src = frames[0].current;
                backingCanvas.width = tempImg.width;
                backingCanvas.height = tempImg.height;

                const gif = new GIF({
                    workers: 2, quality: 10, width: backingCanvas.width, height: backingCanvas.height,
                    workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
                });
                const renderCtx = backingCanvas.getContext('2d');
                
                const bgDrawnImage = new Image();
                bgDrawnImage.src = backgroundData.current;
                await bgDrawnImage.decode();

                for (const frame of frames) {
                    await new Promise(resolve => {
                        const frameImg = new Image();
                        frameImg.onload = () => {
                            renderCtx.clearRect(0,0,backingCanvas.width, backingCanvas.height);
                            // Composite background layers
                            if (uploadedBackgroundImage) renderCtx.drawImage(uploadedBackgroundImage, 0, 0, backingCanvas.width, backingCanvas.height);
                            else { renderCtx.fillStyle = '#FFFFFF'; renderCtx.fillRect(0,0,backingCanvas.width, backingCanvas.height); }
                            renderCtx.drawImage(bgDrawnImage, 0, 0, backingCanvas.width, backingCanvas.height);
                            // Draw animation frame on top
                            renderCtx.drawImage(frameImg, 0, 0, backingCanvas.width, backingCanvas.height);
                            gif.addFrame(backingCanvas, { delay: 1000 / fpsSlider.value, copy: true });
                            resolve();
                        };
                        frameImg.src = frame.current;
                    });
                }
                gif.on('finished', blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = 'animation.gif'; a.click();
                    URL.revokeObjectURL(url);
                    loadingModal.classList.add('hidden');
                });
                gif.render();
            }

            // --- Background Image ---
             function drawUploadedBackground() {
                // handled by redrawAll
            }
            function handleBackgroundUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => { uploadedBackgroundImage = img; redrawAll(); triggerAutosave();};
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = null;
            }
            function clearBackground() { 
                uploadedBackgroundImage = null; 
                pushUndoState(); // for drawing bg
                let img = new Image();
                img.src = backgroundData.current;
                const blankBg = document.createElement('canvas');
                blankBg.width = img.width;
                blankBg.height = img.height;
                backgroundData.current = blankBg.toDataURL();
                redrawAll();
                triggerAutosave();
             }

             // --- Onion Skinning ---
            function renderOnionSkins(isRedrawing) {
                if (!isRedrawing) {
                    redrawAll();
                    return;
                }
                onionBehindCtx.clearRect(0, 0, onionBehindCtx.canvas.width, onionBehindCtx.canvas.height);
                onionAheadCtx.clearRect(0, 0, onionAheadCtx.canvas.width, onionAheadCtx.canvas.height);

                if (!onionSkinCheckbox.checked || activeLayer !== 'animation') return;

                const drawSkin = (ctx, frameIndex) => {
                    if (frameIndex < 0 || frameIndex >= frames.length) return;
                    const img = new Image();
                    img.onload = () => {
                        ctx.globalAlpha = 0.3;
                        ctx.drawImage(img, 0, 0);
                        ctx.globalAlpha = 1.0;
                    };
                    img.src = frames[frameIndex].current;
                };
                
                drawSkin(onionBehindCtx, currentFrameIndex - 1);
                drawSkin(onionAheadCtx, currentFrameIndex + 1);
            }
            
             // --- Color Palette ---
            function renderColorPalette() {
                paletteColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-slate-600';
                    swatch.style.backgroundColor = color;
                    swatch.addEventListener('click', () => {
                        colorPicker.value = color;
                        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                        swatch.classList.add('active');
                    });
                    colorPalette.appendChild(swatch);
                });
            }

            // --- Zoom and Pan ---
            function handleWheel(e) {
                e.preventDefault();
                const zoomFactor = 1.1;
                const oldScale = transform.scale;
                
                if (e.deltaY < 0) { // Zoom in
                    transform.scale = Math.min(transform.scale * zoomFactor, 10);
                } else { // Zoom out
                    transform.scale = Math.max(transform.scale / zoomFactor, 0.1);
                }
                
                const rect = canvasViewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                transform.panX = mouseX - (mouseX - transform.panX) * (transform.scale / oldScale);
                transform.panY = mouseY - (mouseY - transform.panY) * (transform.scale / oldScale);
                
                updateZoomDisplay();
                redrawAll();
            }

            function startPan(e) {
                 if (e.button === 1 || e.which === 2) { // Middle mouse button
                    isPanning = true;
                    lastPanPosition = { x: e.clientX, y: e.clientY };
                    canvasViewport.style.cursor = 'grabbing';
                }
            }
            
            function doPan(e) {
                if (isPanning) {
                    const dx = e.clientX - lastPanPosition.x;
                    const dy = e.clientY - lastPanPosition.y;
                    transform.panX += dx;
                    transform.panY += dy;
                    lastPanPosition = { x: e.clientX, y: e.clientY };
                    redrawAll();
                }
            }

            function endPan(e) {
                isPanning = false;
                canvasViewport.style.cursor = 'default';
            }
            
            function updateZoomDisplay() {
                zoomLevelDisplay.textContent = `${Math.round(transform.scale * 100)}%`;
            }

            function resetZoom() {
                transform.scale = 1;
                const rect = canvasViewport.getBoundingClientRect();
                const canvasRect = document.querySelector('.canvas-container').getBoundingClientRect();
                transform.panX = (rect.width - canvasRect.width) / 2;
                transform.panY = (rect.height - canvasRect.height) / 2;

                updateZoomDisplay();
                redrawAll();
            }



            // --- Event Listeners ---
            canvasViewport.addEventListener('wheel', handleWheel);
            canvasViewport.addEventListener('mousedown', startPan);
            window.addEventListener('mousemove', doPan);
            window.addEventListener('mouseup', endPan);
            
            zoomInBtn.addEventListener('click', () => {
                const rect = canvasViewport.getBoundingClientRect();
                handleWheel({ preventDefault: () => {}, deltaY: -1, clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2 });
            });
            zoomOutBtn.addEventListener('click', () => {
                 const rect = canvasViewport.getBoundingClientRect();
                 handleWheel({ preventDefault: () => {}, deltaY: 1, clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2 });
            });
            zoomResetBtn.addEventListener('click', resetZoom);


            animationCanvas.addEventListener('mousedown', startDrawing);
            animationCanvas.addEventListener('mousemove', draw);
            window.addEventListener('mouseup', stopDrawing);
            animationCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            animationCanvas.addEventListener('touchmove', draw, { passive: false });
            window.addEventListener('touchend', stopDrawing);
            
            toolButtons.forEach(button => {
                button.addEventListener('click', () => {
                    activeTool = button.dataset.tool;
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
            });
            
            animationLayerBtn.addEventListener('click', () => {
                activeLayer = 'animation';
                animationLayerBtn.classList.add('active');
                backgroundLayerBtn.classList.remove('active');
                updateUndoRedoButtons();
                renderOnionSkins();
            });

            backgroundLayerBtn.addEventListener('click', () => {
                activeLayer = 'background';
                backgroundLayerBtn.classList.add('active');
                animationLayerBtn.classList.remove('active');
                updateUndoRedoButtons();
                renderOnionSkins();
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return; 
                if (e.ctrlKey || e.metaKey) {
                    if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                    if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                }
            });

            brushSizeSlider.addEventListener('input', () => { brushSizeValue.textContent = brushSizeSlider.value; });
            addFrameBtn.addEventListener('click', addNewFrame);

            // Sync playback controls
            playPauseBtn.addEventListener('click', () => { isPlaying ? pauseAnimation() : playAnimation(); });
            playPauseMobileBtn.addEventListener('click', () => { isPlaying ? pauseAnimation() : playAnimation(); });
            fpsSlider.addEventListener('input', () => { 
                const val = fpsSlider.value;
                fpsValue.textContent = val;
                fpsSliderMobile.value = val;
                fpsValueMobile.textContent = val;
                updateTimelineInfo();
            });
             fpsSliderMobile.addEventListener('input', () => { 
                const val = fpsSliderMobile.value;
                fpsValueMobile.textContent = val;
                fpsSlider.value = val;
                fpsValue.textContent = val;
                updateTimelineInfo();
            });

            exportGifBtn.addEventListener('click', exportToGif);
            window.addEventListener('resize', resizeAndRedraw);
            closeInstructionsModalBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            showInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            saveProjectBtn.addEventListener('click', saveProjectToFile);
            loadProjectInput.addEventListener('change', loadProjectFromFile);
            bgUploadInput.addEventListener('change', handleBackgroundUpload);
            clearBgBtn.addEventListener('click', clearBackground);
            onionSkinCheckbox.addEventListener('change', renderOnionSkins);
            colorPicker.addEventListener('input', () => {
                 document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            });

            restoreAutosaveBtn.addEventListener('click', () => {
                const savedData = localStorage.getItem('autosavedAnimationProject');
                if (savedData) {
                    try {
                        const projectData = JSON.parse(savedData);
                        loadProjectData(projectData);
                    } catch (e) {
                        console.error("Could not parse autosaved data.", e);
                    }
                }
                autosaveNotification.classList.add('hidden');
            });

            dismissAutosaveBtn.addEventListener('click', () => {
                localStorage.removeItem('autosavedAnimationProject');
                autosaveNotification.classList.add('hidden');
            });
            
            // Gemini Modal Listeners
            generateBgBtn.addEventListener('click', () => geminiModal.classList.remove('hidden'));
            closeGeminiModalBtn.addEventListener('click', () => geminiModal.classList.add('hidden'));
            generateGeminiBtn.addEventListener('click', () => {
                const prompt = geminiPromptInput.value;
                if (prompt) {
                    generateImageWithGemini(prompt);
                }
            });
            useGeminiImageBtn.addEventListener('click', () => {
                const imgSrc = geminiImageResult.src;
                if (imgSrc) {
                    const img = new Image();
                    img.onload = () => {
                        uploadedBackgroundImage = img;
                        redrawAll();
                        triggerAutosave();
                    };
                    img.src = imgSrc;
                    geminiModal.classList.add('hidden');
                    // Reset modal state
                    geminiImageResult.src = '';
                    geminiResultContainer.classList.add('hidden');
                    useGeminiImageBtn.classList.add('hidden');
                    geminiPromptInput.value = '';
                }
            });


            // --- Initialization ---
            function initialize() {
                playPauseMobileBtn.innerHTML = playIcon.outerHTML; // Set initial mobile icon
                renderColorPalette();
                const savedData = localStorage.getItem('autosavedAnimationProject');

                if (savedData) {
                    autosaveNotification.classList.remove('hidden');
                    initializeNewProject();
                } else {
                    initializeNewProject();
                }
                 if (!localStorage.getItem('animationToolInstructionsSeen')) {
                    instructionsModal.classList.remove('hidden');
                    localStorage.setItem('animationToolInstructionsSeen', 'true');
                }
            }
            
            function initializeNewProject() {
                 const backingCanvas = document.createElement('canvas');
                backingCanvas.width = 1920; 
                backingCanvas.height = 1080;
                
                frames = [{
                    current: backingCanvas.toDataURL(),
                    undoStack: [],
                    redoStack: []
                }];
                
                backgroundData.current = backingCanvas.toDataURL();
                
                resizeAndRedraw();
                renderTimeline();
                updateUndoRedoButtons();
                updateTimelineInfo();
                resetZoom();
            }

            initialize();
        });
    </script>
</body>
</html>

