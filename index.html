<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Animation Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .timeline-frame {
            border: 2px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .timeline-frame.active {
            border-color: #4f46e5; /* indigo-600 */
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.7);
        }
        .tool-button.active, .layer-button.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border-color: #6366f1; /* indigo-500 */
        }
        .loader {
            border: 4px solid #4b5563; /* gray-600 */
            border-radius: 50%;
            border-top: 4px solid #4f46e5; /* indigo-600 */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            height: 8px;
        }
        .timeline-container::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        .timeline-container::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* Canvas Layering */
        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            max-width: 100%;
        }
        .base-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            touch-action: none;
        }
        #onion-skin-canvas-behind,
        #onion-skin-canvas-ahead,
        #selection-canvas,
        #preview-canvas { /* preview canvas for shapes */
            pointer-events: none;
        }
        #image-bg-canvas {
             background-color: white;
        }

        /* Disabled button style */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-slate-900 text-gray-300 flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-slate-800 shadow-md p-3 flex justify-between items-center z-20 border-b border-slate-700 flex-shrink-0">
        <h1 class="text-lg md:text-xl font-bold text-white whitespace-nowrap">Web Animation Tool</h1>
        <div class="flex items-center gap-2 md:gap-4">
            <button id="show-instructions" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 md:px-4 rounded-lg text-sm">Help</button>
            <button id="save-project" class="bg-green-600 hover:bg-green-500 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16"><path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v4.5h2a.5.5 0 0 1 .354.854l-2.5 2.5a.5.5 0 0 1-.708 0l-2.5-2.5A.5.5 0 0 1 5.5 6.5h2V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/></svg>
                <span class="hidden md:inline">Save</span>
            </button>
            <label for="load-project-input" class="bg-yellow-500 hover:bg-yellow-400 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2 cursor-pointer">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder2-open" viewBox="0 0 16 16"><path d="M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.958 0 1.76.746 1.97.684l.248-.06c.26-.06.58.11.732.358L8.5 3.5h5.5A1.5 1.5 0 0 1 15.5 5v.54L14.05 8.4a.5.5 0 0 1-.45.3H5.4a.5.5 0 0 1-.45-.3L3.5 5.54V5.5A1.5 1.5 0 0 1 2 4H1.5V3.5zM2 6h12v5a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6z"/><path d="M.5 4a.5.5 0 0 0 0 1h15a.5.5 0 0 0 0-1H.5z"/></svg>
                <span class="hidden md:inline">Load</span>
            </label>
            <input type="file" id="load-project-input" class="hidden" accept=".anim">
             <button id="export-gif" class="bg-purple-600 hover:bg-purple-500 text-white font-bold p-2 md:py-2 md:px-4 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                <span class="hidden md:inline">Export GIF</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-col md:flex-row flex-grow overflow-hidden">
        <!-- Toolbar -->
        <aside class="w-full md:w-64 bg-slate-800 p-4 flex-shrink-0 flex flex-col gap-4 overflow-y-auto z-10 border-b md:border-b-0 md:border-r border-slate-700">
            <!-- Layers -->
            <div>
                <h3 class="text-sm font-semibold mb-1 text-gray-400">Layer</h3>
                 <div class="grid grid-cols-2 gap-2">
                    <button id="animation-layer-btn" class="layer-button active bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Animation</button>
                    <button id="background-layer-btn" class="layer-button bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Background</button>
                </div>
            </div>
            
            <!-- Tools -->
            <div>
                <h3 class="text-sm font-semibold mb-1 text-gray-400">Tool</h3>
                <div id="tools-container" class="grid grid-cols-3 gap-2">
                    <button data-tool="pencil" class="tool-button active p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Pencil">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>
                    </button>
                    <button data-tool="eraser" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Eraser">
                         <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm.66 11.34L3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/></svg>
                    </button>
                    <button data-tool="lasso" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Lasso Erase">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5">
                            <path d="M4.23223 15.7678C1.20573 12.7413 1.20573 7.75868 4.23223 4.73223C7.25873 1.70573 12.2413 1.70573 15.2678 4.73223C18.2943 7.75868 18.2943 12.7413 15.2678 15.7678L12.5 18.5L9.5 21.5L4.23223 15.7678Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4 4"/>
                        </svg>
                    </button>
                     <button data-tool="line" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Line">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.5 19.5L19.5 4.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="rectangle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Rectangle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                    <button data-tool="circle" class="tool-button p-2 rounded-lg aspect-square flex justify-center items-center bg-slate-700 hover:bg-slate-600 border-2 border-slate-600" title="Circle">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </button>
                </div>
            </div>
             <!-- History -->
            <div>
                <h3 class="text-sm font-semibold mb-1 text-gray-400">History</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button id="undo-btn" class="bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 rounded-lg text-sm flex items-center justify-center" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-counterclockwise" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
                        </svg>
                    </button>
                    <button id="redo-btn" class="bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 rounded-lg text-sm flex items-center justify-center" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-clockwise" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <!-- Brush Size -->
            <div>
                <label for="brush-size" class="text-sm font-semibold text-gray-400">Brush Size</label>
                <div class="flex items-center gap-2 mt-2">
                    <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="brush-size-value" class="text-sm font-semibold w-6 text-center">5</span>
                </div>
            </div>
            <!-- Color -->
            <div>
                <label for="color-picker" class="text-sm font-semibold mb-1 text-gray-400">Color</label>
                <input type="color" id="color-picker" value="#000000" class="w-full h-10 rounded-lg cursor-pointer border-2 border-slate-600 mt-2">
            </div>
            <!-- Onion Skin -->
            <div>
                <label for="onion-skin" class="flex items-center cursor-pointer select-none">
                    <input type="checkbox" id="onion-skin" class="h-4 w-4 rounded border-gray-500 text-indigo-500 focus:ring-indigo-600 bg-slate-700">
                    <span class="ml-2 text-sm font-medium">Onion Skin</span>
                </label>
            </div>
            <!-- Background Options -->
            <div>
                <h3 class="text-sm font-semibold mb-1 text-gray-400">Background Options</h3>
                <div class="flex flex-col gap-2">
                    <label for="bg-upload-input" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-sm text-center cursor-pointer">Upload Image</label>
                    <input type="file" id="bg-upload-input" class="hidden" accept="image/*">
                    <button id="clear-bg-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg text-sm">Clear Background</button>
                </div>
            </div>
             <!-- Playback -->
             <div>
                <h3 class="text-sm font-semibold mb-1 text-gray-400">Playback</h3>
                <div class="flex items-center justify-center gap-4 mt-2">
                    <button id="play-pause" class="bg-green-600 hover:bg-green-500 text-white font-bold rounded-full h-10 w-10 flex items-center justify-center">
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                        <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-pause-fill hidden" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>
                        <span id="play-text" class="sr-only">Play</span>
                    </button>
                </div>
                 <div class="flex items-center gap-2 mt-4">
                    <label for="fps-slider" class="text-sm font-medium">FPS:</label>
                    <input type="range" id="fps-slider" min="1" max="30" value="12" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    <span id="fps-value" class="text-sm font-semibold w-6 text-center">12</span>
                </div>
            </div>
        </aside>

        <!-- Canvas -->
        <main class="flex-grow flex items-center justify-center p-2 md:p-4 bg-slate-900 overflow-hidden">
             <div class="canvas-container shadow-xl">
                <canvas id="image-bg-canvas" class="base-canvas"></canvas>
                <canvas id="drawing-bg-canvas" class="base-canvas"></canvas>
                <canvas id="onion-skin-canvas-behind" class="base-canvas"></canvas>
                <canvas id="animation-canvas" class="base-canvas cursor-crosshair"></canvas>
                <canvas id="onion-skin-canvas-ahead" class="base-canvas"></canvas>
                <canvas id="preview-canvas" class="base-canvas"></canvas>
            </div>
        </main>
    </div>

    <!-- Timeline -->
    <footer class="bg-slate-800 shadow-inner p-3 z-20 border-t border-slate-700 flex-shrink-0">
        <h3 class="text-sm font-semibold mb-2 text-center text-gray-400">Timeline</h3>
        <div class="w-full overflow-x-auto pb-2 timeline-container">
            <div id="timeline" class="flex items-center gap-2 p-2 bg-slate-700 rounded-lg h-28">
                 <button id="add-frame" class="flex-shrink-0 bg-slate-600 hover:bg-slate-500 text-gray-300 font-bold h-24 w-40 rounded-lg flex flex-col items-center justify-center text-center p-2" title="Add New Frame">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/></svg>
                    <span class="text-xs mt-1">Add Frame</span>
                 </button>
            </div>
        </div>
    </footer>
    
    <!-- GIF Export library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <!-- Modal for loading spinner -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
        <div class="bg-slate-800 p-8 rounded-lg shadow-xl text-center border border-slate-700">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-lg font-medium text-white">Generating GIF...</p>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 text-white p-8 rounded-lg shadow-xl max-w-2xl w-full border border-slate-700">
            <h2 class="text-2xl font-bold mb-6 text-center">How to Use the Animation Tool</h2>
            <ol class="list-decimal list-inside space-y-3 text-gray-300">
                <li><b>Layers:</b> Switch between drawing on the 'Animation' layer (for moving parts) and the 'Background' layer (for static scenery).</li>
                <li><b>Tools:</b> Select a tool like Pencil, Eraser, Lasso, or Shapes from the sidebar.</li>
                <li><b>Undo/Redo:</b> Use the undo/redo buttons in the sidebar or press <code>Ctrl+Z</code> / <code>Ctrl+Y</code>.</li>
                <li><b>Save/Load Project:</b> Use the 'Save' and 'Load' buttons to save your progress as a <code>.anim</code> file and open it again later.</li>
                <li><b>Background Options:</b> You can either draw your own background on the background layer or upload an image using the 'Upload Image' button.</li>
                <li><b>Add & Duplicate Frames:</b> Use the <span class="text-green-400">'+'</span> button in the timeline to add a new frame. Hover over a frame to find the copy icon to duplicate it.</li>
                <li><b>Onion Skin:</b> Check this box in the toolbar to see faint outlines of your previous and *next* drawings, which helps with smooth animation.</li>
                <li><b>Play & Adjust FPS:</b> Use the play button and <span class="text-yellow-400">FPS</span> slider in the toolbar to preview your animation.</li>
                <li><b>Export GIF:</b> When you're finished, use the 'Export GIF' button to save your animation as a downloadable .gif file.</li>
            </ol>
            <div class="mt-8 text-center">
                <button id="close-instructions-modal" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-8 rounded-lg">Got it!</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvasContainer = document.querySelector('.canvas-container');
            const imageBgCanvas = document.getElementById('image-bg-canvas');
            const drawingBgCanvas = document.getElementById('drawing-bg-canvas');
            const onionBehindCanvas = document.getElementById('onion-skin-canvas-behind');
            const animationCanvas = document.getElementById('animation-canvas');
            const onionAheadCanvas = document.getElementById('onion-skin-canvas-ahead');
            const previewCanvas = document.getElementById('preview-canvas');

            const animCtx = animationCanvas.getContext('2d', { willReadFrequently: true });
            const imageBgCtx = imageBgCanvas.getContext('2d');
            const drawingBgCtx = drawingBgCanvas.getContext('2d');
            const onionBehindCtx = onionBehindCanvas.getContext('2d');
            const onionAheadCtx = onionAheadCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');

            // --- DOM Elements ---
            const animationLayerBtn = document.getElementById('animation-layer-btn');
            const backgroundLayerBtn = document.getElementById('background-layer-btn');
            const toolsContainer = document.getElementById('tools-container');
            const toolButtons = document.querySelectorAll('.tool-button');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const colorPicker = document.getElementById('color-picker');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const onionSkinCheckbox = document.getElementById('onion-skin');
            const addFrameBtn = document.getElementById('add-frame');
            const timeline = document.getElementById('timeline');
            const playPauseBtn = document.getElementById('play-pause');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const fpsSlider = document.getElementById('fps-slider');
            const fpsValue = document.getElementById('fps-value');
            const exportGifBtn = document.getElementById('export-gif');
            const loadingModal = document.getElementById('loading-modal');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsModalBtn = document.getElementById('close-instructions-modal');
            const showInstructionsBtn = document.getElementById('show-instructions');
            const saveProjectBtn = document.getElementById('save-project');
            const loadProjectInput = document.getElementById('load-project-input');
            const bgUploadInput = document.getElementById('bg-upload-input');
            const clearBgBtn = document.getElementById('clear-bg-btn');

            // --- State ---
            let frames = [];
            let backgroundData = {
                current: null,
                undoStack: [],
                redoStack: []
            };
            let currentFrameIndex = 0;
            let isDrawing = false;
            let activeTool = 'pencil';
            let activeLayer = 'animation'; // 'animation' or 'background'
            let shapeStartPos = null;
            let isPlaying = false;
            let animationFrameId;
            let lastFrameTime = 0;
            let uploadedBackgroundImage = null;
            let lassoPoints = [];

            // --- Canvas Setup ---
            function resizeCanvas() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                [imageBgCanvas, drawingBgCanvas, onionBehindCanvas, animationCanvas, onionAheadCanvas, previewCanvas].forEach(c => {
                    c.width = width;
                    c.height = height;
                });
                
                if (!backgroundData.current) {
                    backgroundData.current = drawingBgCanvas.toDataURL();
                }

                drawUploadedBackground();
                redrawAll();
            }

             function redrawAll() {
                loadFrame(currentFrameIndex);
                loadBackground();
                renderOnionSkins();
                frames.forEach((_, i) => updateTimelineThumbnail(i));
            }
            
            // --- History (Undo/Redo) ---
            function getActiveHistory() {
                return activeLayer === 'animation' ? frames[currentFrameIndex] : backgroundData;
            }

            function pushUndoState() {
                const history = getActiveHistory();
                if (!history) return;
                history.undoStack.push(history.current);
                history.redoStack = []; // Clear redo stack on new action
                if (history.undoStack.length > 30) { 
                    history.undoStack.shift();
                }
                updateUndoRedoButtons();
            }
            
            function undo() {
                const history = getActiveHistory();
                if (!history || history.undoStack.length === 0) return;
                history.redoStack.push(history.current);
                history.current = history.undoStack.pop();
                
                const targetCtx = activeLayer === 'animation' ? animCtx : drawingBgCtx;
                const img = new Image();
                img.onload = () => {
                    clearCanvas(targetCtx);
                    targetCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height);
                    if (activeLayer === 'animation') {
                        updateTimelineThumbnail(currentFrameIndex);
                        renderOnionSkins();
                    }
                };
                img.src = history.current;
                updateUndoRedoButtons();
            }

            function redo() {
                const history = getActiveHistory();
                if (!history || history.redoStack.length === 0) return;
                history.undoStack.push(history.current);
                history.current = history.redoStack.pop();
                
                const targetCtx = activeLayer === 'animation' ? animCtx : drawingBgCtx;
                const img = new Image();
                img.onload = () => {
                    clearCanvas(targetCtx);
                    targetCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height);
                     if (activeLayer === 'animation') {
                        updateTimelineThumbnail(currentFrameIndex);
                        renderOnionSkins();
                    }
                };
                img.src = history.current;
                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                const history = getActiveHistory();
                if (!history) {
                    undoBtn.disabled = true;
                    redoBtn.disabled = true;
                    return;
                };
                undoBtn.disabled = history.undoStack.length === 0;
                redoBtn.disabled = history.redoStack.length === 0;
            }


            // --- Drawing Logic ---
            function getMousePos(e) {
                const rect = animationCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                return {
                    x: (clientX - rect.left),
                    y: (clientY - rect.top)
                };
            }
            
            function getActiveContext() {
                return activeLayer === 'animation' ? animCtx : drawingBgCtx;
            }

            function startDrawing(e) {
                if (e.touches) e.preventDefault();
                isDrawing = true;
                const pos = getMousePos(e);
                const currentCtx = getActiveContext();

                if (['pencil', 'eraser'].includes(activeTool)) {
                    pushUndoState();
                    currentCtx.beginPath();
                    currentCtx.moveTo(pos.x, pos.y);
                    draw(e);
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    shapeStartPos = pos;
                } else if (activeTool === 'lasso') {
                    lassoPoints = [pos];
                    clearCanvas(previewCtx);
                }
            }
            
            function draw(e) {
                if (!isDrawing) return;
                if (e.touches) e.preventDefault();
                const pos = getMousePos(e);
                const currentCtx = getActiveContext();
                
                if (['pencil', 'eraser'].includes(activeTool)) {
                    currentCtx.lineWidth = brushSizeSlider.value;
                    currentCtx.lineCap = 'round';
                    currentCtx.lineJoin = 'round';
                    currentCtx.globalCompositeOperation = activeTool === 'eraser' ? 'destination-out' : 'source-over';
                    currentCtx.strokeStyle = colorPicker.value;
                    currentCtx.lineTo(pos.x, pos.y);
                    currentCtx.stroke();
                    currentCtx.beginPath();
                    currentCtx.moveTo(pos.x, pos.y);
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    drawShapePreview(pos);
                } else if (activeTool === 'lasso') {
                    lassoPoints.push(pos);
                    drawLassoPath();
                }
            }

            function stopDrawing(e) {
                if (!isDrawing) return;
                isDrawing = false;
                const currentCtx = getActiveContext();
                
                if (['pencil', 'eraser'].includes(activeTool)) {
                    currentCtx.beginPath();
                } else if (['line', 'rectangle', 'circle'].includes(activeTool)) {
                    pushUndoState();
                    drawShape(getMousePos(e));
                    shapeStartPos = null;
                } else if (activeTool === 'lasso') {
                    if (lassoPoints.length > 2) {
                        pushUndoState();
                        applyLassoDelete();
                    }
                    lassoPoints = [];
                    clearCanvas(previewCtx);
                }
                
                if (activeLayer === 'animation') {
                    saveFrame();
                } else {
                    saveBackground();
                }
            }
            
            // --- Shape Drawing Logic ---
            function drawShapePreview(currentPos) {
                clearCanvas(previewCtx);
                previewCtx.lineWidth = brushSizeSlider.value;
                previewCtx.strokeStyle = colorPicker.value;
                previewCtx.beginPath();
                
                const start = shapeStartPos;
                const end = currentPos;
                
                if (activeTool === 'line') {
                    previewCtx.moveTo(start.x, start.y);
                    previewCtx.lineTo(end.x, end.y);
                } else if (activeTool === 'rectangle') {
                    previewCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (activeTool === 'circle') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    previewCtx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                }
                previewCtx.stroke();
            }

            function drawShape(endPos) {
                clearCanvas(previewCtx);
                const currentCtx = getActiveContext();
                currentCtx.lineWidth = brushSizeSlider.value;
                currentCtx.strokeStyle = colorPicker.value;
                currentCtx.lineCap = 'round';
                currentCtx.lineJoin = 'round';
                currentCtx.globalCompositeOperation = 'source-over';
                currentCtx.beginPath();

                const start = shapeStartPos;
                const end = endPos;

                if (activeTool === 'line') {
                    currentCtx.moveTo(start.x, start.y);
                    currentCtx.lineTo(end.x, end.y);
                } else if (activeTool === 'rectangle') {
                    currentCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (activeTool === 'circle') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    currentCtx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                }
                currentCtx.stroke();
            }


             // --- Lasso Logic ---
            function drawLassoPath() {
                if (lassoPoints.length < 2) return;
                clearCanvas(previewCtx);
                previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                previewCtx.lineWidth = 2;
                previewCtx.setLineDash([6, 6]);
                previewCtx.beginPath();
                previewCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    previewCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                previewCtx.stroke();
                previewCtx.setLineDash([]);
            }

            function applyLassoDelete() {
                const currentCtx = getActiveContext();
                currentCtx.save();
                currentCtx.beginPath();
                currentCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    currentCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                }
                currentCtx.closePath();
                currentCtx.clip();
                currentCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                currentCtx.restore();
            }

            // --- Project Save/Load ---
            function saveProject() {
                const projectData = {
                    frames: frames.map(f => f.current),
                    drawnBackground: backgroundData.current,
                    uploadedImage: uploadedBackgroundImage ? uploadedBackgroundImage.src : null,
                };
                const jsonString = JSON.stringify(projectData);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation-project.anim';
                a.click();
                URL.revokeObjectURL(url);
            }

            function loadProject(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        if (!projectData.frames) throw new Error('Invalid project file');
                        
                        frames = projectData.frames.map(frameDataURL => ({
                            current: frameDataURL, undoStack: [], redoStack: [],
                        }));

                        backgroundData = {
                            current: projectData.drawnBackground || drawingBgCanvas.toDataURL(),
                            undoStack: [], redoStack: []
                        };

                        currentFrameIndex = 0;

                        const loadVisuals = () => {
                            renderTimeline();
                            redrawAll();
                            updateUndoRedoButtons();
                        };
                        
                        if (projectData.uploadedImage) {
                            const img = new Image();
                            img.onload = () => { uploadedBackgroundImage = img; loadVisuals(); };
                            img.src = projectData.uploadedImage;
                        } else {
                            uploadedBackgroundImage = null; loadVisuals();
                        }
                    } catch (error) {
                        console.error("Error loading project:", error);
                        alert('Could not load project file.');
                    }
                };
                reader.readAsText(file);
                e.target.value = null;
            }

            // --- Frame Management ---
            function saveFrame() {
                if (!frames[currentFrameIndex]) return;
                frames[currentFrameIndex].current = animationCanvas.toDataURL();
                updateTimelineThumbnail(currentFrameIndex);
            }

            function loadFrame(index) {
                clearCanvas(animCtx);
                if (index < 0 || index >= frames.length) return;
                const img = new Image();
                img.onload = () => { animCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height); };
                img.src = frames[index].current;
            }

            function saveBackground() {
                backgroundData.current = drawingBgCanvas.toDataURL();
            }
            
            function loadBackground() {
                 clearCanvas(drawingBgCtx);
                 if (!backgroundData.current) return;
                 const img = new Image();
                 img.onload = () => { drawingBgCtx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height); };
                 img.src = backgroundData.current;
            }


            function clearCanvas(context) {
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            }

            // --- Timeline UI ---
            function renderTimeline() {
                const frameElements = timeline.querySelectorAll('.relative.flex-shrink-0.group');
                frameElements.forEach(el => el.remove());
                
                frames.forEach((_, index) => {
                    const frameContainer = createFrameElement(index);
                    timeline.insertBefore(frameContainer, addFrameBtn);
                });
                frames.forEach((_, index) => { updateTimelineThumbnail(index); });
                updateActiveFrame();
            }
            
            function createFrameElement(index) {
                const frameContainer = document.createElement('div');
                frameContainer.className = 'relative flex-shrink-0 group';
                const frameElement = document.createElement('canvas');
                frameElement.className = 'timeline-frame h-24 w-40 bg-white rounded-lg cursor-pointer border-2 border-slate-600';
                frameElement.dataset.index = index;
                frameContainer.appendChild(frameElement);
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.className = 'absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full h-6 w-6 flex items-center justify-center font-bold opacity-0 group-hover:opacity-100 transition-opacity';
                deleteBtn.title = 'Delete Frame';
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteFrame(index); };
                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-files" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg>';
                copyBtn.className = 'absolute top-0 left-0 -mt-2 -ml-2 bg-blue-500 text-white rounded-full h-6 w-6 flex items-center justify-center font-bold opacity-0 group-hover:opacity-100 transition-opacity';
                copyBtn.title = 'Duplicate Frame';
                copyBtn.onclick = (e) => { e.stopPropagation(); copyFrame(index); };
                frameContainer.appendChild(deleteBtn);
                frameContainer.appendChild(copyBtn);
                frameElement.addEventListener('click', () => {
                    if (isPlaying) return;
                    if(activeLayer === 'animation') saveFrame(); else saveBackground();
                    currentFrameIndex = index;
                    loadFrame(index);
                    updateActiveFrame();
                    renderOnionSkins();
                    updateUndoRedoButtons();
                });
                return frameContainer;
            }

            function updateTimelineThumbnail(index) {
                const thumbCanvas = timeline.querySelector(`canvas[data-index='${index}']`);
                if (!thumbCanvas || !frames[index] || !frames[index].current) return;
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCanvas.width = thumbCanvas.offsetWidth * 2;
                thumbCanvas.height = thumbCanvas.offsetHeight * 2;
                const img = new Image();
                img.onload = () => {
                    thumbCtx.fillStyle = 'white';
                    thumbCtx.fillRect(0,0,thumbCanvas.width, thumbCanvas.height);
                    thumbCtx.drawImage(img, 0, 0, thumbCanvas.width, thumbCanvas.height);
                };
                img.src = frames[index].current;
            }

            function updateActiveFrame() {
                timeline.querySelectorAll('.timeline-frame').forEach((el, i) => {
                    el.classList.toggle('active', i === currentFrameIndex);
                });
            }
            
            function addNewFrame() {
                saveFrame();
                const newCanvas = document.createElement('canvas');
                newCanvas.width = animationCanvas.width; newCanvas.height = animationCanvas.height;
                const newFrame = {
                    current: newCanvas.toDataURL(),
                    undoStack: [],
                    redoStack: []
                };
                frames.splice(currentFrameIndex + 1, 0, newFrame);
                currentFrameIndex++;
                loadFrame(currentFrameIndex);
                renderTimeline();
                renderOnionSkins();
                updateUndoRedoButtons();
            }
            
            function deleteFrame(index) {
                if (frames.length <= 1) return;
                frames.splice(index, 1);
                currentFrameIndex = Math.max(0, currentFrameIndex >= index ? currentFrameIndex - 1 : currentFrameIndex);
                loadFrame(currentFrameIndex);
                renderTimeline();
                renderOnionSkins();
                updateUndoRedoButtons();
            }

            function copyFrame(index) {
                const frameToCopy = frames[index];
                const newFrame = {
                    current: frameToCopy.current,
                    undoStack: [],
                    redoStack: []
                };
                frames.splice(index + 1, 0, newFrame);
                currentFrameIndex = index + 1;
                loadFrame(currentFrameIndex);
                renderTimeline();
                renderOnionSkins();
                updateUndoRedoButtons();
            }

            // --- Animation Playback ---
            function playAnimation() {
                if (isPlaying) return; isPlaying = true;
                playIcon.classList.add('hidden'); pauseIcon.classList.remove('hidden');
                lastFrameTime = performance.now();
                animationLoop();
            }

            function pauseAnimation() {
                isPlaying = false;
                playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden');
                cancelAnimationFrame(animationFrameId);
            }
            
            function animationLoop(currentTime) {
                if (!isPlaying) return;
                animationFrameId = requestAnimationFrame(animationLoop);
                const timeSinceLastFrame = currentTime - lastFrameTime;
                const frameInterval = 1000 / fpsSlider.value;
                if (timeSinceLastFrame > frameInterval) {
                    lastFrameTime = currentTime - (timeSinceLastFrame % frameInterval);
                    currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                    loadFrame(currentFrameIndex);
                    updateActiveFrame();
                }
            }

            // --- GIF Export ---
            async function exportToGif() {
                loadingModal.classList.remove('hidden');
                const gif = new GIF({
                    workers: 2, quality: 10, width: animationCanvas.width, height: animationCanvas.height,
                    workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
                });
                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = animationCanvas.width; renderCanvas.height = animationCanvas.height;
                const renderCtx = renderCanvas.getContext('2d');
                
                const bgDrawnImage = new Image();
                bgDrawnImage.src = backgroundData.current;
                await bgDrawnImage.decode();

                for (const frame of frames) {
                    await new Promise(resolve => {
                        const frameImg = new Image();
                        frameImg.onload = () => {
                            renderCtx.clearRect(0,0,renderCanvas.width, renderCanvas.height);
                            // Composite background layers
                            if (uploadedBackgroundImage) renderCtx.drawImage(uploadedBackgroundImage, 0, 0, renderCanvas.width, renderCanvas.height);
                            else { renderCtx.fillStyle = '#FFFFFF'; renderCtx.fillRect(0,0,renderCanvas.width, renderCanvas.height); }
                            renderCtx.drawImage(bgDrawnImage, 0, 0, renderCanvas.width, renderCanvas.height);
                            // Draw animation frame on top
                            renderCtx.drawImage(frameImg, 0, 0, renderCanvas.width, renderCanvas.height);
                            gif.addFrame(renderCanvas, { delay: 1000 / fpsSlider.value, copy: true });
                            resolve();
                        };
                        frameImg.src = frame.current;
                    });
                }
                gif.on('finished', blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = 'animation.gif'; a.click();
                    URL.revokeObjectURL(url);
                    loadingModal.classList.add('hidden');
                });
                gif.render();
            }

            // --- Background Image ---
             function drawUploadedBackground() {
                clearCanvas(imageBgCtx);
                if (uploadedBackgroundImage) { imageBgCtx.drawImage(uploadedBackgroundImage, 0, 0, imageBgCanvas.width, imageBgCanvas.height); } 
            }
            function handleBackgroundUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => { uploadedBackgroundImage = img; drawUploadedBackground(); };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = null;
            }
            function clearBackground() { 
                uploadedBackgroundImage = null; 
                drawUploadedBackground();
                pushUndoState(); // for drawing bg
                const blankBg = document.createElement('canvas');
                blankBg.width = animationCanvas.width; blankBg.height = animationCanvas.height;
                backgroundData.current = blankBg.toDataURL();
                loadBackground();
             }

             // --- Onion Skinning ---
            function renderOnionSkins() {
                clearCanvas(onionBehindCtx);
                clearCanvas(onionAheadCtx);
                if (!onionSkinCheckbox.checked || activeLayer !== 'animation') return;

                const drawSkin = (ctx, frameIndex) => {
                    if (frameIndex < 0 || frameIndex >= frames.length) return;
                    const img = new Image();
                    img.onload = () => {
                        ctx.globalAlpha = 0.3;
                        ctx.drawImage(img, 0, 0, animationCanvas.width, animationCanvas.height);
                        ctx.globalAlpha = 1.0;
                    };
                    img.src = frames[frameIndex].current;
                };
                
                drawSkin(onionBehindCtx, currentFrameIndex - 1);
                drawSkin(onionAheadCtx, currentFrameIndex + 1);
            }

            // --- Event Listeners ---
            animationCanvas.addEventListener('mousedown', startDrawing);
            animationCanvas.addEventListener('mousemove', draw);
            window.addEventListener('mouseup', stopDrawing);
            animationCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            animationCanvas.addEventListener('touchmove', draw, { passive: false });
            window.addEventListener('touchend', stopDrawing);
            
            toolButtons.forEach(button => {
                button.addEventListener('click', () => {
                    activeTool = button.dataset.tool;
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
            });
            
            animationLayerBtn.addEventListener('click', () => {
                activeLayer = 'animation';
                animationLayerBtn.classList.add('active');
                backgroundLayerBtn.classList.remove('active');
                updateUndoRedoButtons();
                renderOnionSkins();
            });

            backgroundLayerBtn.addEventListener('click', () => {
                activeLayer = 'background';
                backgroundLayerBtn.classList.add('active');
                animationLayerBtn.classList.remove('active');
                updateUndoRedoButtons();
                renderOnionSkins();
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return; 
                if (e.ctrlKey || e.metaKey) {
                    if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                    if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                }
            });

            brushSizeSlider.addEventListener('input', () => { brushSizeValue.textContent = brushSizeSlider.value; });
            addFrameBtn.addEventListener('click', addNewFrame);
            playPauseBtn.addEventListener('click', () => { isPlaying ? pauseAnimation() : playAnimation(); });
            fpsSlider.addEventListener('input', () => { fpsValue.textContent = fpsSlider.value; });
            exportGifBtn.addEventListener('click', exportToGif);
            window.addEventListener('resize', resizeCanvas);
            closeInstructionsModalBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            showInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectInput.addEventListener('change', loadProject);
            bgUploadInput.addEventListener('change', handleBackgroundUpload);
            clearBgBtn.addEventListener('click', clearBackground);
            onionSkinCheckbox.addEventListener('change', renderOnionSkins);

            // --- Initialization ---
            function initialize() {
                const blankCanvas = document.createElement('canvas');
                blankCanvas.width = 1280; blankCanvas.height = 720;
                
                frames.push({
                    current: blankCanvas.toDataURL(),
                    undoStack: [],
                    redoStack: []
                });
                
                backgroundData.current = blankCanvas.toDataURL();
                
                resizeCanvas();
                renderTimeline();
                loadFrame(0);
                loadBackground();
                updateTimelineThumbnail(0);
                updateUndoRedoButtons();

                 if (!localStorage.getItem('animationToolInstructionsSeen')) {
                    instructionsModal.classList.remove('hidden');
                    localStorage.setItem('animationToolInstructionsSeen', 'true');
                }
            }
            initialize();
        });
    </script>
</body>
</html>
